# Alguns atalhos seguirão uma convenção de prefixos
# Créditos: https://github.com/honza/vim-snippets/blob/master/snippets/cs.snippets
#
# Prefixos de acesso (poo)
# ----------------------------
# + = public
# # = protected
# - = private
#
# Sufixos de tipificação do snippet (específicos)
# ----------------------------
# % = bloco de código específico para uma situação
# ! = esqueleto de um arquivo completo
# ? = asssertion php test
# .phtml
snippet ?> "<?php ... ?>"
	<?php
	${0:// ...}
	?>
snippet ?= "<?=...=>"
	<?=${0}?>
snippet ?f "<?php foreach ($values as $value): ?> ... <?php endforeach ?>"
	<?php foreach($${1:values} as $${2:value}): ?>
	${0:<!-- ... -->}
	<?php endforeach ?>
snippet ?fk "<?php foreach ($values as $key => $value): ?> ... <?php endforeach ?>"
	<?php foreach($${1:values} as $${2:key} => $${3:value}): ?>
	${0:<!-- ... -->}
	<?php endforeach ?>
snippet ?i "<?php if(condition): ?> ... <?php endif ?>"
	<?php if(${1:condition}): ?>
	${0:<!-- ... -->}
	<?php endif ?>
snippet ?e
	<?php else: ?>
	${0:<!-- ... -->}


# geral
snippet ? "<?php ..."
	<?php

	${0:// ...} 
snippet ec "echo value;"
	echo ${0:value};
snippet inc "include '...'"
	include '${1:file}';
snippet inc1 "include_once '...'"
	include_once '${1:file}';
snippet req require '...'
	require '${1:file}';
snippet req1 "require_once '...'"
	require_once '${1:file}';
snippet ns "namespace ..."
	namespace ${1:`substitute(substitute(expand("%:h"), '\v^\w+\/(\u)', '\1', ''), '\/', '\\\', 'g')`};
snippet t "$this->..."
	$this->
snippet f "function funcName(...):return { ... }"
	function ${1:funcName}(${2:type $param}):${3:typeReturn}
	{
		${0:// ...}
	}
snippet $? "$foo = condition ? return a : return b"
	$${1:foo} = ${2:condition} ? ${3:return a} : ${4:return b};
snippet ?: "condition ? do a : do b"
	${1:condition} ? ${2:do a} : ${3:do b};
snippet dd "var_dump( ... );die;"
	var_dump(${1}); die(${0:});
snippet /* "/** * */"
	/**
	 * ${0}
	 */
snippet def "define('VARIABLE_NAME', 'definition')"
	define('${1:VARIABLE_NAME}', ${2:'definition'});
snippet wh "while (condition) { ... }"
	while (${1:true}) {
		${0:// ...}
	}
snippet do "do { ... } while (condition)"
	do {
		${0:// ...}
	} while (${1});
snippet if "if (condition) { ... }"
	if (${1:true}) {
		${0:// ...}
	}
snippet ife "if (condition) { ... } else { ... }"
	if (${1:true}) {
		${0:// ...}
	} else {

	}
snippet elif "elseif(condition) { ... }"
	elseif (${1:true}) {
		${0:// ...}
	}
snippet switch "switch($var) { case 'xyz': ... default: .... }"
	switch ($${1:variable}) {
		case '${2:value}':
			${3:// ...}
			break;
		default:
			${4:// ...}
			break;
	}
snippet case "case 'value': ... break"
	case '${1:value}':
		${0:// ...}
		break;
snippet for "for ($i = 0; $i < $count; $i++) { ... }"
	for($${2:i} = 0; $$2 < ${1:count}; $$2${3:++}) {
		${0:// ...}
	}
snippet foreach "foreach ($var as $value) { .. }"
	foreach($${1:variable} as $${2:value}) {
		${0:// ...}
	}
snippet foreachk "foreach ($var as $key => $value) { .. }"
	foreach($${1:variable} as $${2:key} => $${3:value}) {
		${0:// ...}
	}
snippet try "try { ... } catch (Exception $e) { ... }"
	try {
		${1:// ...}
	} catch (${2:Exception} $e) {
		${2:// ...}
	}
snippet rett "return true"
	return true;
snippet retf "return false"
	return false;
snippet te "throw new Exception()"
	throw new ${1:Exception}("${2:Error Processing Request}");
snippet fpc "file_put_contents(file, content, FILE_APPEND)"
	file_put_contents(${1:file}, ${2:content}${3:, FILE_APPEND});
snippet sr "str_replace(search, replace, subject)"
	str_replace(${1:search}, ${2:replace}, ${3:subject});
snippet ina "in_array($needle, $ar)"
	in_array(${1:needle}, $${2:ar})
snippet iss "isset($var)"
	isset(${1:var})
snippet isn "is_null($var)"
	is_null($${1:var})
snippet fe "file_exists($file)"
	file_exists(${1:file})
snippet id "is_dir('path')"
	is_dir(${1:path})

# poo
snippet __c "__construct"
	function __construct(${1:type $param})
	{
		${0:// ...}
	}

snippet + "private $property"
	public $${0:propertyName};
snippet - "private $property"
	private $${0:propertyName};
snippet # "protected $property"
	protected $${0:propertyName};
snippet +f "public function() { ... }"
	public function ${1:functionName}(${2:type $param}):${3:typeReturn}
	{
		${0:// ...}
	}

snippet -f "private function() { ... }"
	private function ${1:functionName}(${2:type $param}):${3:typeReturn}
	{
		${0:// ...}
	}
snippet #f "protected function() { ... }"
	protected function ${1:functionName}(${2:type $param}):${3:typeReturn}
	{
		${0:// ...}
	}
snippet gs "Getter and Setter"
	public function get${2:$1}()
	{
		return $this->${1:p};
	}

	public function set$2(${3:type }$$1)
	{
		$this->$1 = $$1;
	}

	${0:// ...}
snippet $g "$var->get...(...)"
	$${1:foo}->get${0:Property}();
snippet $s "$var->set...(...)"
	$${1:foo}->set${2:Property}(${0});

# skeletons
snippet c! "class skeleton"
	<?php

	namespace ${1:Foo\Bar\Baz};

	class ${2:`Filename()`}
	{
		${0:// ...}
	}
snippet i! "interface skeleton"
	<?php

	namespace ${1:Foo\Bar\Baz};

	interface ${1:`Filename()`}
	{
		${0:// ...}
	}
snippet t! "trait skeleton"
	<?php

	namespace ${1:Foo\Bar\Baz};

	trait ${1:`Filename()`}
	{
		${0:// ...}
	}

# Predefined variables
snippet C "$_COOKIE['...']"
	$_COOKIE['${1:variable}']
snippet E "$_ENV['...']"
	$_ENV['${1:variable}']
snippet F "$_FILES['...']"
	$_FILES['${1:variable}']
snippet G "$_GET['...']"
	$_GET['${1:variable}']
snippet P "$_POST['...']"
	$_POST['${1:variable}']
snippet R "$_REQUEST['...']"
	$_REQUEST['${1:variable}']
snippet S "$_SERVER['...']"
	$_SERVER['${1:variable}']
snippet SS "$_SESSION['...']"
	$_SESSION['${1:variable}']

# block codes
snippet json "header('Content-Type: application/json'); return json_encode(...);"
	$data = /** whatever you're serializing **/;
	header('Content-Type: application/json');
	return json_encode($data);

#################################################### TDD
# phpunit
snippet e? "$this->assertEquals($a, $b)"
	$this->assertEquals(${1:$expected}, ${2:$actual});
snippet ne? "$this->assertNotEquals($a, $b)"
	$this->assertNotEquals(${1:$expected}, ${2:$actual});
snippet f? "$this->assertFalse($a)"
	$this->assertFalse(${1});
snippet t? "$this->assertTrue($a)"
	$this->assertTrue(${1});
snippet fe? "$this->assertFileExists('path/to/file')"
	$this->assertFileExists(${1:'path/to/file'});
snippet fne? "$this->assertFileNotExists('path/to/file')"
	$this->assertFileNotExists(${1:'path/to/file'});
snippet c? "$this->assertContains($needle, $haystack)"
	$this->assertContains(${1:$needle}, ${2:$haystack});
snippet nc? "$this->assertNotContains($needle, $haystack)"
	$this->assertNotContains(${1:$needle}, ${2:$haystack});
snippet co? "$this->assertContainsOnly($needle, $haystack)"
	$this->assertContainsOnly(${1:$needle}, ${2:$haystack});
snippet coio? "$this->assertContainsOnlyInstancesOf(Example::class, $haystack)"
	$this->assertContainsOnlyInstancesOf(${1:Example}::class, ${2:$haystack});
snippet ahk? "$this->assertArrayHasKey($key, $array)"
	$this->assertArrayHasKey(${1:$key}, ${2:$array});
snippet anhk? "$this->assertArrayNotHasKey($key, $array)"
	this->assertArrayNotHasKey(${1:$key}, ${2:$array});
snippet cha? "$this->assertClassHasAttribute($name, Example::class)"
	$this->assertClassHasAttribute(${1:$attributeName}, ${2:Example}::class);
snippet io? "$this->assertInstanceOf(Example::class, $actual)"
	$this->assertInstanceOf(${1:Example}::class, ${2:$actual});
snippet itype? "$this->assertInternalType('string', $actual)"
	$this->assertInternalType(${1:'string'}, ${2:actual});
snippet count? "$this->assertCount($count, $haystack)"
	$this->assertCount(${1:$expectedCount}, ${2:$haystack});
snippet ncount? "$this->assertNotCount($count, $haystack)"
	$this->assertNotCount(${1:$count}, ${2:$haystack});
snippet as? "$this->assertArraySubset($subset, $array)"
	$this->assertArraySubset(${1:$subset}, ${2:$array});
snippet null? "$this->assertNull($a)"
	$this->assertNull(${1});
snippet nnull? "$this->assertNotNull($a)"
	$this->assertNotNull(${1});
snippet ut "public function testXYZ() { ... } // unity test"
	public function test${1}()
	{
		${0:// ...}
	}

