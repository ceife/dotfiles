" vim: set formatoptions+=t:
"
" Arquivo de configura√ß√µes b√°sicas do vim, podendo ser adicionado de maneira
" independente do repo dotfiles. Basta copiar o conte√∫do para o
" %userprofile%\_vimrc no Windows ou $HOME/.vimrc no Linux.
" Tamb√©m pode testar essas configura√ß√µes com:
"   - vim -u <path/to/vimrc>
"
" AUTHOR: Neni @nenitf <http://neni.dev/hub>
" SOURCE: https://raw.githubusercontent.com/nenitf/dotfiles/master/vim/vimrc
"
" INCENTIVO:    ‚îÇ
"               ‚îú(+) simplicidade
"               ‚îú(-) manuten√ß√£o
"               ‚îú(+) performance
"               ‚îú(+) flow
"               ‚îú(+) entusiamo
"               ‚îú(+) estudo
"               ‚îú(+) qualidade de c√≥digo
"               ‚îú(-) bug em produ√ß√£o
"               ‚îî(+) üéâüéâüéâ
"
" PRECEITOS:
"   - Focar em perf windows e linux
"   - Organizar o trecho de c√≥digo no fold correto
"   - Manter o KISS, n√£o reescrever o vim! Lembrar que:
"       - A configura√ß√£o ser√° usada crossplatform (windows x linux)
"       - De boa usar terminal ao lado do vim, nem tudo tem que ser como emacs
"   - Manter compatibilidade entre vim e nvim
"   - Evitar trocar comandos default do teclado
"   - Usar/configurar a menor quantidade de plugins poss√≠vel
"   - Comentar/documentar bastante o c√≥digo (respeitando a largura de coluna)
"       - Configura√ß√µes antigas, novas e defaults
"
" UPGRADES: Ver arquivo wiki/vim.md
"
" DICAS:
"   - Usar K (:h K) em cima da palavra da configura√ß√£o para consultar manual
"   - Nos folds:
"       - zR e zM abre e fecha recursivamente todo arquivo (map: <f2>)
"       - za abre e fecha (toggle) um folder (map: <tab>)
"       - [z ]z gg G de um fold aberto
"       - zj zk pulo de fold
"   - Propriedades que s√£o setadas podem voltar ao seu valor inicial com &,
"   por exemplo set wildmenu&
"   - Formatar largura dos coment√°rios com Vgq (por causa do formatoptions+=t)
"
"## B√°sico
" M√≠nimas configura√ß√µes para usar o vim

" quebra compatibilidade com vi
" evita erros bizarros como de interpreta√ß√£o de dicion√°rios e etc
set nocompatible

"### Conte√∫do
set encoding=utf-8
"TODO entender configs abaixo:
"set fileencoding=utf-8 "?
"set fileencodings=utf-8 "?

set fileformats=unix,dos,mac "?
"TODO entender configs abaixo:
"set bomb "?
"set binary "?

" ^M, n√£o sei como resolvi ainda!
" THANKS: https://stackoverflow.com/questions/6496778/vim-run-autocmd-on-all-filetypes-except
"fun! Dos2unix()
"    " Don't strip on these filetypes
"    " :echo &ft
"    if &ft =~ 'startify\|nerdtree'
"        return
"    endif
"    :e ++ff=dos
"endfun
" autocmd BufRead * call Dos2unix()

"### Vim n√£o-bloqueante
" checar/atualizar quando o texto for modificado (ocorre mt com o git)
set autoread
au FocusGained,BufEnter * :silent!<space>!
" au FocusGained,BufEnter * checktime

"### RuntimePaths
" Deve vir antes das defini√ß√µes de filetype
" carrega ftdetect, para definir extens√µes a filetypes
set rtp+=~/dev/dotfiles/vim
" evita autocmd de highligh (syntax/) e espec√≠ficas do filetype (ftplugin/)
set rtp+=~/dev/dotfiles/vim/after

" O vim utilizado pelo git para commitar no Windows √© diferente do que fica
" instalado no sistema. Portanto o mesmo n√£o procura em ~/vimfiles/pack/ os
" packages (plugins), mas sim em ~/.vim (padr√£o Linux).
" Como solu√ß√£o basta adicionar manualmente, aparentemente n√£o tem problema em
" em escolher duas vezes o mesmo diret√≥rio (caso seja aberto o gvim ao inv√©s
" de commitar por exemplo). Ao inv√©s de setar o runtinme de todos snippets,
" bode ser usado o packpath (:h packpath)
" THANKS: https://superuser.com/a/1466466
"set rtp+=~/vimfiles/pack/*/start/*
set pp+=~/vimfiles

"### Syntax e identa√ß√£o
" syntax de acordo com o filetype
syntax on

" carrega ftplugin.vim e indent.vim do runtimepath (plugins)
filetype plugin indent on

" permite usar <bs> mesmo indo contra auto-intent, eol e inicio da linha
" https://vi.stackexchange.com/questions/2162/why-doesnt-the-backspace-key-work-in-insert-mode
set backspace=indent,eol,start

"### Apar√™ncia e som
" colorscheme default, sobescrito com plugins
colorscheme slate
" ajusta cores para um fundo escuro
set background=dark
" for√ßa uso de 256 cores, permitindo highlight hexadecimal, com guibg e guifg
" ao inv√©s de somente ctermbg e ctermfg
set t_Co=256
set termguicolors

" Remove som ao apertar multiplos ESCs
" https://vim.fandom.com/wiki/Disable_beeping"
set noerrorbells novisualbell t_vb=
set belloff=all " cancela v√°rios beeps, incluindo <esc><esc>

"## Comportamento

set showmatch               " exibe fechamento de {[()]}
set showmode                " exibe mode no canto inferior esquerdo
set showcmd                 " exibe os comandos no canto inferior direito
set autoindent              " auto indenta√ß√£o
set mouse=a                 " libera uso do mouse em todos modos
set linebreak               " quebra a linha por palavra e n√£o por letra
"set cursorcolumn cursorline " marca colunha e linha do cursor
set number relativenumber   " exibe r√©gua com o numero relativo das linhas
set nrformats-=octal        " ctrl-a ctrl -x
set clipboard+=unnamed      " acessa/altera copy do so
set lazyredraw              " N√£o redesenha a tela durante macro (+ perf)

"set splitbelow              " cria split horizontal abaixo
"set splitright              " cria split vertical abaixo

set nobackup                " para n√£o criar arquivo de bkp
set noswapfile              " para n√£o criar arquivo swap (?)

set scrolloff=3             " mant√™m 3 linhas acima/abaixo do cursor em scroll

" Limite de coluna, comentado para ser posto em modelines espec√≠ficas
" set textwidth=80            " define largura da linha de texto
" set formatoptions+=t        " quebra a linha na coluna textwidth (Vgq)
set colorcolumn=81          " marca coluna 81, ideal para impress√£o com :ha

" motivos para usar buffers em segundo plano ao inv√©s de tabs:
"   - o mesmo arquivo n√£o √© aberto duas vezes
"   - mais velocidade pois a janela n√£o precisa ser redesenhada
set hidden " mant√™m o arquivo dispon√≠vel ao sair dele (mesmo modificado)
" :ls lista, :b <numero><tab> acessa buffers

set hlsearch    " colore os matches de search (* / %s)
set incsearch   " vai colorindo a pesquisa durante a digita√ß√£o
set ignorecase  " ignora case sensitive na busca

" renderiza√ß√£o de emojis
"if has("directx")
"    " renderiza emojis, afeta perf
"    " Para ativar basta usar :call NN_ToggleEmoji
"    set renderoptions=type:directx,gamma:1.0,contrast:0.1,level:1.0,geom:1,renmode:5,taamode:1
"    set emoji " ??? noemoji
"endif
set emoji
set renderoptions=

" t√≠tulo da janela
"set title
"set titlestring=%<%F

"## Modeline

" Exemplo de modeline (pode ser em coment√°rio):
" vim: set fdm=marker:

set modeline        " habilita uso da modeline
set modelines=5     " procura as 5 primeiras ou ultimas linhas do arquivo

"## Statusline

set laststatus=2                " habilita statusline
set statusline=                 " reseta statusline
set statusline+=\ %r\%m\%f\     " nome readonly, modificado e nome abreviado
set statusline+=\%=				" espa√ßo
set statusline+=\ %p%%\ %l:\%c  " rownumber, total e percentual
set statusline+=\ %y            " filetype

"## Popup de sugest√£o

set wildmenu                " habilita menu
" https://vi.stackexchange.com/questions/5029/key-mapping-that-will-invoke-the-wildmenu
set wildcharm=<tab>         " char para chamar wildmenu de um map
set completeopt=menuone     " mostra menu de op√ß√µes
set shortmess+=c            " remove mensagens in√∫teis do wildmenu

" Remove das sugest√µes arquivos/diretorios (lvimgrep tb)
" THANKS: https://stackoverflow.com/questions/1898987/how-to-exclude-file-patterns-in-vimgrep
set wildignore=node_modules/*
set wildignore+=dist/*
set wildignore+=vendor/*
set wildignore+=_site/*

":h ins-completion
" origem das palavras do wildmenu:
"   - buffer corrente
"   - buffers escondidos
"   - dicin√°rios
"   - de outras janelas (splits)
set complete=.,b,k,w
" tags no wildmenu afetam perf

" escolhe palavras do omnifunc de acordo com o filetype do buffer aberto
set omnifunc=syntaxcomplete#Complete    " <c-x><c-o>

"### Tabs/espa√ßos

" https://stackoverflow.com/questions/1878974/redefine-tab-as-4-spaces
set tabstop=4
set softtabstop=4
set shiftwidth=4
set smarttab
set expandtab

"## Fold

" m√©todo padr√£o de fold
set foldmethod=marker
set foldtext=FoldTextMarker()

" :h digraph-table-mbyte
set fillchars=vert:\|,fold:‚îÄ

" retorna t√≠tulo dos folds padr√£o marker com {{{}}}
" THANKS: https://stackoverflow.com/questions/5983396/change-the-text-in-folds
" THANKS: https://jdhao.github.io/2019/08/16/nvim_config_folding/
" THANKS: https://dhruvasagar.com/2013/03/28/vim-better-foldtext
function! FoldTextMarker()
  let lines_count = v:foldend - v:foldstart + 1

  " :h digraph-table-mbyte
  let lines_count_text = '‚î§' . printf("%4s", lines_count) . '‚îú'
  let foldchar = matchstr(&fillchars, 'fold:\zs.')

    " remove marca√ß√£o de coment√°rios # // /* <!--
    let titulo = substitute(getline(v:foldstart),"^[#*{\/ \"<!--]*","",'g')

    " remove marca√ß√£o de coment√°rios */
    let titulo = substitute(titulo,"\*\/*$","",'g')
    " remove marca√ß√£o de coment√°rios -->
    let titulo = substitute(titulo,"\-\-\>*$","",'g')
    " remove espa√ßos que sobraram ao final da linha
    let titulo = substitute(titulo,"\ *$","",'g')

  " cria + de acordo com # (foldlevel)
  let foldtextstart = repeat('+', v:foldlevel) . ' ' . titulo

  let foldtextend = lines_count_text . repeat(foldchar, 8)
  let foldtextlength = strlen(substitute(foldtextstart . foldtextend, '.', 'x', 'g')) + &foldcolumn
  return foldtextstart  . ' ' . repeat(foldchar, winwidth(0)-foldtextlength) . foldtextend
endfunction

"## Netrw
" Netrw no lugar do nerdtree, usar :Lexplore para toggle
" - :edit a folder to open a file browser
" - <CR>/v/t to open in an h-split/v-split/tab
" - check |netrw-browse-maps| for more mappings

"TODO Como n√£o criar NetrwTreeListing (???) e .netrwhist? (???)
" https://github.com/tpope/vim-vinegar/issues/13
" autocmd FileType netrw setlocal bufhidden=delete

"let g:netrw_banner=0        " disable annoying banner
"let g:netrw_browse_split=4  " open in prior window
" FIXME N√£o funciona de primeira
let g:netrw_liststyle=3     " tree view

" Exibe numeros (ruler)
" THANKS: https://stackoverflow.com/a/8731175
let g:netrw_bufsettings = 'noma nomod nu nobl nowrap ro'

"## Fun√ß√µes
"### NN_
" Fun√ß√µes que s√£o usadas com frequencia n√£o t√£o alta para serem comandos ou
" maps, padr√£o NN_ para ficar f√°cil achar com :call NN_<tab>
" Fun√ß√µes muito usadas por√©m n√£o tanto a ponto de virarem comandos ou maps
" O padr√£o NN_ serve para ficar f√°cil achar com :call NN_<tab>

" habilita e desabilita emojis, ideal para perf
function! NN_EmojiToggle()
    if &renderoptions == ""
        set renderoptions=type:directx,gamma:1.0,contrast:0.1,level:1.0,geom:1,renmode:5,taamode:1
    else
        set renderoptions=
    endif
endfun

" atualiza diret√≥rio atual (:pwd) com dir do projeto, com raiz .git
" THANKS: https://michaelheap.com/set-parent-git-directory-to-current-path-in-vim/
function! NN_SetGitDir()
    " Change working dir to the current file
    cd %:p:h
    " Set 'gitdir' to be the folder containing .git
    let gitdir=system("git rev-parse --show-toplevel")
    " See if the command output starts with 'fatal' (if it does, not in a git repo)
    let isnotgitdir=matchstr(gitdir, '^fatal:.*')
    " If it empty, there was no error. Let's cd
    if empty(isnotgitdir)
        cd `=gitdir`
    endif
endfunction

" abre :Lexplorer com pwd como do git
" THANKS: https://michaelheap.com/set-parent-git-directory-to-current-path-in-vim/
function! NN_Lexplorer()
    call NN_SetGitDir()
    Lexplore
endfunction

" lista todos e fixmes tags
" THANKS: https://www.commandlinefu.com/commands/view/12833/get-a-list-of-all-todofixme-tasks-left-to-be-done-in-your-project
" OBS: Ir√° ignorar path do wildignore https://stackoverflow.com/a/20042050
" FIXME ativa :GitGutterToggle
fun! NN_Tasks()
    call NN_SetGitDir()
    "silent !git grep -EIn "TODO|FIXME"
    lvimgrep /\C\<TODO\>\|\C\<FIXME\>/j **
    lopen
endfun

"#### Git
function NN_Git_add()
    echo "n√£o implementado!"
endfun

"### Private (script)
" Fun√ß√µes privadas que s√£o usadas unicamente no vimrc

" carrega arquivo se ele existe
" THANKS: https://devel.tech/snippets/n/vIIMz8vZ/load-vim-source-files-only-if-they-exist/
function! SourceIfExists(file)
  if filereadable(expand(a:file))
    exe 'source' a:file
	"else
	"echo "N√£o existe o arquivo:"  a:file
  endif
endfunction

"### Shared
" Fun√ß√µes que s√£o mapeadas, portanto n√£o devem ficar com NN_

" https://stackoverflow.com/questions/20933836/what-is-the-difference-between-location-list-and-quickfix-list-in-vim
" THANKS: https://github.com/jmharvey/vim/blob/master/vimrc#L207
" THANKS: https://vimrcfu.com/snippet/104
" FIXME Ativa gitguttertoggle
fun! Grep(grepword)
    call NN_SetGitDir()
    if len(a:grepword) == 0
        let s:grepword = input("Grep: ")        
    else
        let s:grepword = a:grepword
    endif
    "exec "silent !git grep -EIn \"" . grepword . "\""
    " exec "vimgrep /".s:kwd."/ %"|" No arquivo
    exec "lvimgrep /\\<" . s:grepword . "\\>/j **"
    lopen
endfun

" THANKS: https://github.com/nvie/vimrc/blob/master/vimrc
let g:quickfix_is_open = 0
function! s:QuickfixToggle()
    if g:quickfix_is_open
        cclose
        let g:quickfix_is_open = 0
        execute g:quickfix_return_to_window . "wincmd w"
    else
        let g:quickfix_return_to_window = winnr()
        copen
        let g:quickfix_is_open = 1
    endif
endfunction

" Fun√ß√£o utilizada para limpar a tela do terminal
" Dependendo do SO muda o comando...
fun! LimpaTerminal()
    if has("win32")
        silent !cls
    else
        silent !clear
    endif
endfun

highlight link NeniTagJump DiffAdd
match NeniTagJump /<++>/
function! JumpToTag()
    " search retorna a linha onde o parametro foi encontrado
    if search("<++>",'nw') > 0
        " posiciona o cursor sob o padr√£o da marca√ß√£o
        call search("<++>",'w')
        " Caso a marca√ß√£o esteja na ultima coluna da linha, o :startinsert
        " recua uma coluna a mais. Como seria muito complexo calcular essa
        " situa√ß√£o, √© mais f√°cil entrar no modo de insert e apagar o numero
        " de letras (4 para <++>)
        call feedkeys("i\<del>\<del>\<del>\<del>")
    endif
endfun

fun! TestaTriggerSnippet(root, func1)
    let c = nr2char(getchar(0))
    if c == "\<tab>"
        let s:snippetfunc = function(a:func1)
        let @x = s:snippetfunc()
    elseif c == "\<esc>"
        execute "normal! a" . a:root . 'a'
        execute 'normal! "_x'
    else
        " execute "normal a".a:root.c
        execute "normal! a" . a:root . '"' . c
        execute 'normal! h"_x'
        startinsert
        call cursor( line('.'), col('.') + 1)
    endif
endfun

"## Comandos

" recarrega vimrc com trigger para o filetype
" THANKS: https://vi.stackexchange.com/questions/9338/why-cannot-i-source-vimrc-for-the-current-file-being-editing
command! Sov source $MYVIMRC | e %

" fechar (sem for√ßar) todos buffers e deixar somente um
" THANKS: https://salferrarello.com/vim-close-all-buffers-except-the-current-one/
command! BufOnly execute 'kb|%bdelete|e #|b#|bd%|normal `b'

" abre terminal em split, ideal para o gvim
" FIXME n√£o funciona corretamente no linux
" THANKS: https://stackoverflow.com/a/38082196
command! TerminalGitRootVertical exec 'call NN_SetGitDir() | vert term ++kill=term'
command! TerminalGitRootHorizontal exec 'call NN_SetGitDir() | term ++kill=term'

" Necessario instalar ctags ou universal ctags
" Att ctags
command! Ctags !ctags -R .<CR>

command! Grep :call Grep("")<cr>

" Ver highlight-groups
"   :so $VIMRUNTIME/syntax/hitest.vim
" Ver highlight group da palavra sob o cursor
" https://vim.fandom.com/wiki/Identify_the_syntax_highlighting_group_used_at_the_cursor
" :highlight mostra as cores do grupo
command! Syntax echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<' . synIDattr(synID(line("."),col("."),0),"name") . "> lo<" . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"

"## Mapeamentos

":map -> lista todos mapeamentos para o arquivo

" TODO ver funcionamento do localleader (:h maplocalleader)
let mapleader="\<space>"

noremap     <leader><leader>    :w<CR>
noremap     <leader><cr>        :call NN_Lexplorer()<cr>
inoremap    <leader><tab>       <esc>:call JumpToTag()<cr>| " <++>
nnoremap    <leader><tab>       <esc>:call JumpToTag()<cr>| " <++>
nnoremap    <leader>/           :noh<cr>
noremap     <leader>.           :pwd<CR>
nnoremap    <leader>dd          :bd<CR>
nnoremap    <leader>df          :bd!<CR>
noremap     <leader>e           :on<CR>| " Close all splits
noremap     <leader>h           :<C-u>split<CR>
noremap     <leader>j           :<C-u>sp
noremap     <leader>l           :<C-u>vsp
nnoremap    <leader>t           :tn <c-r><c-w><CR>| " Goto definition (ctags)
noremap     <leader>v           :<C-u>vsplit<CR>
noremap     <leader>y           my^vg_"+y:echo "Copiado!!"<CR>
vnoremap    <leader>y           "+y:echo "Copiado!!"<CR>

nnoremap    #           :b #<CR>|" FIXME volta para unlisted buffer tbm
vnoremap    <           <gv|" mant√™m select ap√≥s indenta√ß√£o
vnoremap    >           >gv|" mant√™m select ap√≥s indenta√ß√£o
inoremap    "           ""<left>|"autoclose
inoremap    '           ''<left>|"autoclose
inoremap    {           {}<left>|"autoclose
inoremap    {<CR>       {}<left><CR><Esc>O|"autoclose
inoremap    {<space>    {}<left><space><space><left>|"autoclose
inoremap    (           ()<left>|"autoclose
inoremap    (<CR>       ()<left><CR><Esc>O|"autoclose
inoremap    (<space>    ()<left><space><space><left>|"autoclose
inoremap    [           []<left>|"autoclose
inoremap    [<CR>       []<left><CR><Esc>O|"autoclose
inoremap    [<space>    []<left><space><space><left>|"autoclose
vnoremap    a'          c'<c-r>"'|" surround match
vnoremap    a"          c"<c-r>""|" surround match
vnoremap    a(          c(<c-r>")|" surround match
vnoremap    a{          c{<c-r>"}|" surround match
vnoremap    a[          c[<c-r>"]|" surround match
vnoremap    J           :m '>+1<CR>gv=gv| " move sele√ß√£o pra baixo
vnoremap    K           :m '<-2<CR>gv=gv| " move sele√ß√£o pra cima
inoremap    kj          <esc>|" esc mais f√°cil
nnoremap    n           nzzzv|" centraliza match do search
nnoremap    N           Nzzzv|" centraliza match do search
nnoremap    Q           @q|" executa macro em 'q' (letra que mais gravo)
nnoremap    <tab>       za|" toggle fold
nnoremap    <expr><f2>  &foldlevel ? 'zM' :'zR'| " Toggle fold todo arquivo
noremap     <up>        <nop>|" for√ßa hjkl
noremap     <down>      <nop>|" for√ßa hjkl
noremap     <left>      <nop>|" for√ßa hjkl
noremap     <right>     <nop>|" for√ßa hjkl
inoremap    <up>        <nop>|" for√ßa hjkl
inoremap    <down>      <nop>|" for√ßa hjkl
inoremap    <left>      <nop>|" for√ßa hjkl
inoremap    <right>     <nop>|" for√ßa hjkl
inoremap    <c-a>       <C-O>yiW<End>=<C-R>=<C-R>0<CR>| " tip 73 (vim.fandom)
inoremap    <c-f>       <c-o>|" pulo mais ergonomico
nmap        <c-f>       :call NN_<tab><left>| " fun√ß√µes pessoais
nnoremap    <c-g>       viwy:call Grep("<c-r>0")<cr>|" grep palavra do cursor
vnoremap    <c-g>       y:call Grep("<c-r>0")<cr>|" grep da sele√ß√£o
inoremap    <c-h>       <left>|" for√ßa hjkl
inoremap    <c-j>       <down>|" for√ßa hjkl
noremap     <c-j>       <C-w>w| " estilo DWM
inoremap    <c-k>       <up>|" for√ßa hjkl
noremap     <c-k>       <C-w>W| " estilo DWM
inoremap    <c-l>       <right>|" for√ßa hjkl
nnoremap    <C-q>       :call <SID>QuickfixToggle()<cr>
nnoremap    <c-s>       mi<esc>gg=G`i|" indenta todo o arquivo
nnoremap    <c-z>       u|" remove comportamento <c-z>

"## Abrevia√ß√µes
" Evitar ...
"cnoreabbrev cul set cul
"cnoreabbrev nocul set nocul

cnoreabbrev W! w!
cnoreabbrev Q! q!
cnoreabbrev Qa! qa!
cnoreabbrev QA! qa!
cnoreabbrev Wq wq
cnoreabbrev Wa wa
cnoreabbrev wQ wq
cnoreabbrev WQ wq
cnoreabbrev W w
cnoreabbrev Q q
cnoreabbrev Qa qa
cnoreabbrev QA qa

" THANKS: https://vim.fandom.com/wiki/Find_in_files_within_Vim
cabbrev lvim
      \ noautocmd lvim /\<lt><C-R><C-W>\>/gj
      \ **<C-R>=(expand("%:e")=="" ? "" : ".".expand("%:e"))<CR>
      \ <Bar> lw
      \ <C-Left><C-Left><C-Left>

"## AutoCmds

"https://vi.stackexchange.com/questions/9455/why-should-i-use-augroup
augroup tempos
    autocmd InsertEnter * set timeoutlen=200
    autocmd InsertLeave * set timeoutlen=1000
augroup END

"### ftdetect

"https://www.reddit.com/r/vim/wiki/where_to_put_filetype_specific_stuff
"FIXME Como colocar defini√ß√£o de filetype em ftdetect?
augroup skeletons
    au!
    au BufRead,BufNewFile *.gv setfiletype dot
augroup END

"### PHP

let g:dict_dir = "~/dev/dotfiles/vim/dicionarios/"
augroup php
    au BufRead *test.php execute "setlocal dictionary+=".g:dict_dir."phpunit.dict"
augroup END

"## packs pessoais
" Funcionalidades que podem virar mini packages/plugins.
" Alguns podem estar em packages.vim
"### Highlight Word
" Colore palavras (como se fosse o search)
" Antes do pack: 
" nnoremap    <kMultiply> *N| "https://stackoverflow.com/a/24537701
" THANKS: https://bitbucket.org/sjl/dotfiles/raw/d8f861e3276a89c0f98637725006da658adcda90/vim/vimrc

function! HiInterestingWord(n)
    " Defini√ß√£o do highlight, por algum motivo pelo vimrc n√£o ocorre
    hi def InterestingWord1 guifg=#000000 ctermfg=16 guibg=#ffa724 ctermbg=214
    hi def InterestingWord2 guifg=#000000 ctermfg=16 guibg=#aeee00 ctermbg=154
    hi def InterestingWord3 guifg=#000000 ctermfg=16 guibg=#8cffba ctermbg=121
    hi def InterestingWord4 guifg=#000000 ctermfg=16 guibg=#b88853 ctermbg=137
    hi def InterestingWord5 guifg=#000000 ctermfg=16 guibg=#ff9eb8 ctermbg=211
    hi def InterestingWord6 guifg=#000000 ctermfg=16 guibg=#ff2c4b ctermbg=195

    " Save our location.
    normal! mz

    " Yank the current word into the z register.
    normal! "zyiw

    " Calculate an arbitrary match ID.  Hopefully nothing else is using it.
    let mid = 86750 + a:n

    " Clear existing matches, but don't worry if they don't exist.
    silent! call matchdelete(mid)

    " Construct a literal pattern that has to match at boundaries.
    let pat = '\V\<' . escape(@z, '\') . '\>'

    " Actually match the words.
    call matchadd("InterestingWord" . a:n, pat, 1, mid)

    " Move back to our original location.
    normal! `z
endfunction

" TODO remover/resetar um ou todos highlights
nnoremap <leader>1 :call HiInterestingWord(1)<cr>
nnoremap <leader>2 :call HiInterestingWord(2)<cr>
nnoremap <leader>3 :call HiInterestingWord(3)<cr>
nnoremap <leader>4 :call HiInterestingWord(4)<cr>
nnoremap <leader>5 :call HiInterestingWord(5)<cr>
nnoremap <leader>6 :call HiInterestingWord(6)<cr>

"### Coment√°rio
" THANKS: https://stackoverflow.com/a/24046914
let s:comment_map = { 
            \   "c": '\/\/',
            \   "cpp": '\/\/',
            \   "dot": '\/\/',
            \   "go": '\/\/',
            \   "java": '\/\/',
            \   "javascript": '\/\/',
            \   "lua": '--',
            \   "scala": '\/\/',
            \   "php": '\/\/',
            \   "python": '#',
            \   "ruby": '#',
            \   "rust": '\/\/',
            \   "sh": '#',
            \   "desktop": '#',
            \   "fstab": '#',
            \   "conf": '#',
            \   "profile": '#',
            \   "bashrc": '#',
            \   "bash_profile": '#',
            \   "mail": '>',
            \   "eml": '>',
            \   "bat": 'REM',
            \   "ahk": ';',
            \   "vim": '"',
            \   "tex": '%',
            \ }

function! ToggleComment()
    if has_key(s:comment_map, &filetype)
        let comment_leader = s:comment_map[&filetype]
        if getline('.') =~ "^\\s*" . comment_leader . " " 
            " Uncomment the line
            execute "silent s/^\\(\\s*\\)" . comment_leader . " /\\1/"
        else 
            if getline('.') =~ "^\\s*" . comment_leader
                " Uncomment the line
                execute "silent s/^\\(\\s*\\)" . comment_leader . "/\\1/"
            else
                " Comment the line
                execute "silent s/^\\(\\s*\\)/\\1" . comment_leader . " /"
            end
        end
    end
endfunction

nnoremap gcc :call ToggleComment()<cr>
vnoremap gcc :call ToggleComment()<cr>

"## sources
call SourceIfExists("~/dev/dotfiles/vim/dotfiles.vim")
call SourceIfExists("~/dev/dotfiles/vim/packages.vim")
call SourceIfExists("~/.extra-vimrc.vim")

" carrega vimrc se existente em no work dir (:h :pwd :h 'getcwd()')
" ideal para setar wildignore para remover pesquisa de paths de libs
" TODO remover source quando outro .exrc for carregado
au DirChanged * :call SourceIfExists(fnamemodify('.exrc', ":p"))
" exrc n√£o resolve o problema pois ele s√≥ carrega o .vimrc .exrc _vimrc ou
" _exrc no momento que o vim √© aberto no diret√≥rio, ou seja, o startify n√£o da
" o gatilho, mas √© uma op√ß√£o legal
"set exrc
"set secure
" THANKS: https://superuser.com/a/532673

