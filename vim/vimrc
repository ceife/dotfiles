" Arquivo de configura√ß√µes b√°sicas do vim, podendo ser adicionado de maneira
" independente do repo dotfiles. Basta copiar o conte√∫do para o
" %userprofile%\_vimrc no Windows ou $HOME/.vimrc no Linux.
" Tamb√©m pode testar essas configura√ß√µes com:
"   - vim -u <path/to/vimrc>
"
" AUTHOR: Neni @nenitf <http://neni.dev/hub>
" SOURCE: https://raw.githubusercontent.com/nenitf/dotfiles/master/vim/vimrc
"
" INCENTIVO:    ‚îÇ
"               ‚îú(+) simplicidade
"               ‚îú(-) manuten√ß√£o
"               ‚îú(+) performance
"               ‚îú(+) flow
"               ‚îú(+) entusiamo
"               ‚îú(+) estudo
"               ‚îú(+) qualidade de c√≥digo
"               ‚îú(-) bug em produ√ß√£o
"               ‚îî(+) üéâüéâüéâ
"
" PRECEITOS:
"   - Focar em perf windows e linux
"   - Organizar o trecho de c√≥digo no fold correto
"   - Manter o KISS, n√£o reescrever o vim! Lembrar que:
"       - A configura√ß√£o ser√° usada crossplatform (windows x linux)
"       - De boa usar terminal ao lado do vim, nem tudo tem que ser como emacs
"   - Manter compatibilidade entre vim e nvim
"   - Evitar trocar comandos default do teclado
"   - Usar/configurar a menor quantidade de plugins poss√≠vel
"   - Comentar/documentar bastante o c√≥digo (respeitando a largura de coluna)
"       - Configura√ß√µes antigas, novas e defaults
"
" UPGRADES: Ver arquivo wiki/vim.md
"
" DICAS:
"   - Usar K (:h K) em cima da palavra da configura√ß√£o para consultar manual
"   - Nos folds:
"       - zR e zM abre e fecha recursivamente todo arquivo (map: <f2>)
"       - za abre e fecha (toggle) um folder (map: <tab>)
"       - [z ]z gg G de um fold aberto
"       - zj zk pulo de fold
"   - Propriedades que s√£o setadas podem voltar ao seu valor inicial com &,
"   por exemplo set wildmenu&
"   - Formatar largura dos coment√°rios com Vgq (por causa do formatoptions+=t)
"   - Comandos para testar perf:
"       - :syntime on e :syntime report
"       - abrir vim no terminal com vim --startuptime tempo.txt tempo.txt
"       - abrir vim no terminal com vim -u NONE (remove vimrc)
"
"## Vari√°veis
let g:dotfiles_dir = "~/dev/dotfiles"

if filereadable(expand("~/.vimrc-pre.vim"))
    exe 'source ~/.vimrc-pre.vim'
    " Sugest√µes para o pre-vimrc.vim
    " set pythonthreehome=~/AppData/Local/Programs/Python/Python38-32
    " set pythonthreedll=~/AppData/Local/Programs/Python/Python38-32/python38.dll
endif

"## B√°sico
" M√≠nimas configura√ß√µes para usar o vim

" quebra compatibilidade com vi
" evita erros bizarros como de interpreta√ß√£o de dicion√°rios e etc
set nocompatible

"### Conte√∫do
set encoding=utf-8
"TODO entender configs abaixo:
"set fileencoding=utf-8 "?
"set fileencodings=utf-8 "?

set fileformats=unix,dos,mac "?
"TODO entender configs abaixo:
"set bomb "?
"set binary "?

" ^M, n√£o sei como resolvi ainda!
" THANKS: https://stackoverflow.com/questions/6496778/vim-run-autocmd-on-all-filetypes-except
"fun! Dos2unix()
"    " Don't strip on these filetypes
"    " :echo &ft
"    if &ft =~ 'startify\|nerdtree'
"        return
"    endif
"    :e ++ff=dos
"endfun
" autocmd BufRead * call Dos2unix()

"### Vim n√£o-bloqueante
" checar/atualizar quando o texto for modificado (ocorre mt com o git)
set autoread
au FocusGained,BufEnter * :silent!<space>!
" au FocusGained,BufEnter * checktime

"### RuntimePaths
" Deve vir antes das defini√ß√µes de filetype
" carrega ftdetect, para definir extens√µes a filetypes
execute "set rtp+=".g:dotfiles_dir."/vim"
" evita autocmd de highligh (syntax/) e espec√≠ficas do filetype (ftplugin/)
execute "set rtp+=".g:dotfiles_dir."/vim/after"

" O vim utilizado pelo git para commitar no Windows √© diferente do que fica
" instalado no sistema. Portanto o mesmo n√£o procura em ~/vimfiles/pack/ os
" packages (plugins), mas sim em ~/.vim (padr√£o Linux).
" Como solu√ß√£o basta adicionar manualmente, aparentemente n√£o tem problema em
" escolher duas vezes o mesmo diret√≥rio (caso seja aberto o gvim ao inv√©s de
" commitar por exemplo). Ao inv√©s de setar o runtinme de todos snippets, bode
" ser usado o packpath (:h packpath)
" THANKS: https://superuser.com/a/1466466
"set rtp+=~/vimfiles/pack/*/start/*
set pp+=~/vimfiles

"### Syntax e identa√ß√£o
" syntax de acordo com o filetype
" TODO diferen√ßa entre on e enabled
" syntax on
syntax enable

" carrega ftplugin.vim e indent.vim do runtimepath (plugins)
filetype plugin indent on

" permite usar <bs> mesmo indo contra auto-intent, eol e inicio da linha
" https://vi.stackexchange.com/questions/2162/why-doesnt-the-backspace-key-work-in-insert-mode
set backspace=indent,eol,start

"### Apar√™ncia e som
" colorscheme default, sobescrito com plugins
colorscheme slate
" ajusta cores para um fundo escuro
set background=dark
" for√ßa uso de 256 cores, permitindo highlight hexadecimal, com guibg e guifg
" ao inv√©s de somente ctermbg e ctermfg
set t_Co=256
set termguicolors

" Remove som ao apertar multiplos ESCs
" https://vim.fandom.com/wiki/Disable_beeping"
set noerrorbells novisualbell t_vb=
set belloff=all " cancela v√°rios beeps, incluindo <esc><esc>

" habilita conceal
set conceallevel=2

"#### Syntax e Highlight"
":verbose highlight <highlightGroup>

" Corrige highlights padr√µes
" Caso seja necess√°rio corrigir syntax de um plugin, deve ser feito em packages.vim

function FixHighlight()
  highlight link typescriptDOMDocProp typescriptProp
  highlight link typescriptPaymentShippingOptionProp typescriptProp
  highlight link typescriptPaymentMethod typescriptProp
  highlight link typescriptDOMEventProp typescriptProp

  highligh link gitcommitSummary gitcommitFirstLine
  
  " highlight SpellBad term=underline gui=undercurl guisp=Orange
  highlight SpellBad guifg=#000000 guibg=#af0000 gui=bold ctermfg=black ctermbg=red
endfun

augroup override_highlights
  autocmd!
  autocmd ColorScheme * call FixHighlight()
augroup END

"## Comportamento

set showmatch                   " exibe fechamento de {[()]}
set showmode                    " exibe mode no canto inferior esquerdo
set showcmd                     " exibe os comandos no canto inferior direito
set autoindent                  " auto indenta√ß√£o
set mouse=                      " restringe uso do mouse em todos modos ("a" libera)
set linebreak                   " quebra a linha por palavra e n√£o por letra
set nocursorcolumn nocursorline " n√£o marca colunha e linha do cursor (perf)
set number norelativenumber     " exibe r√©gua sem numero relativo (perf)
set nrformats-=octal            " ctrl-a ctrl -x
set lazyredraw                  " n√£o redesenha a tela durante macro (+ perf)

" utiliza clipboard do linux e windows para copiar e colar (y e p)
set clipboard^=unnamedplus,unnamed

"set splitbelow                  " cria split horizontal abaixo (help estranho)
"set splitright                  " cria split vertical abaixo

set nobackup                    " para n√£o criar arquivo de bkp
set noswapfile                  " para n√£o criar arquivo swap (?)

set scrolloff=3                 " mant√™m 3 linhas acima/abaixo do cursor em scroll

" Limite de coluna, comentado para ser posto em modelines espec√≠ficas
" set textwidth=80            " define largura da linha de texto
set colorcolumn=              " afeta perf
" set colorcolumn=81          " marca coluna 81, ideal para impress√£o com :ha
"                             " interessante deixar na modeline com cc

" op√ß√µes de auto inser√ß√£o de blocos. Alguns filetypes j√° possuem
" por default diferentes configura√ß√µes, portanto √© mais interessante add ou
" remover (+= e -=). Abaixo os valores poss√≠veis (:h fo-table)
" t     quebra automatica do texto de acordo com textwidth
"       ideal colocar na modeline: tw=80 fo+=t
" c     quebra autom√°tica do texto de coment√°rios
" r     insere marca√ß√£o de coment√°rio (:set comments?) quando usado <cr> no
"       insert a partir de um coment√°rio
" o     insere marca√ß√£o de coment√°rio ao criar nova linha com 'o' no normal
" q     permite formata√ß√£o com Vgq (depende do textwidth)
" w     TODO
" a     TODO
" n     add automaticamente 2) 3) 4) ...
" v     TODO
" b     TODO
" l     n√£o quebra linhas que ao entrar no insert ja passaram o textwidth
" m     TODO
" M     TODO
" B     TODO
" 1     TODO
" j     ao juntar linhas de coment√°rios com 'J' remove o caracter de
"       coment√°rio intermedi√°rio
" p     TODO
set formatoptions+=jcr

" motivos para usar buffers em segundo plano ao inv√©s de tabs:
"   - o mesmo arquivo n√£o √© aberto duas vezes
"   - mais velocidade pois a janela n√£o precisa ser redesenhada
set hidden " mant√™m o arquivo dispon√≠vel ao sair dele (mesmo modificado)
" :ls lista, :b <numero><tab> acessa buffers

set hlsearch    " colore os matches de search (* / %s)
set incsearch   " vai colorindo a pesquisa durante a digita√ß√£o
set ignorecase  " ignora case sensitive na busca
set nosmartcase " case sensitive se a primeira letra for maiuscula,
"               " ruim para autocomplete de nomes de fun√ß√µes

" renderiza√ß√£o de emojis
"if has("directx")
"    " renderiza emojis, afeta perf
"    " Para ativar basta usar :call NN_ToggleEmoji
"    set renderoptions=type:directx,gamma:1.0,contrast:0.1,level:1.0,geom:1,renmode:5,taamode:1
"    set emoji " ??? noemoji
"endif
set noemoji
set renderoptions=

" t√≠tulo da janela
"set title
"set titlestring=%<%F

"## Modeline

set modeline        " habilita uso da modeline
set modelines=5     " procura as 5 primeiras ou ultimas linhas do arquivo

" Exemplo de modeline (pode ser em coment√°rio):
" vim: set fdm=marker:
" vim: set fo+=t tw=80:
" vim: set sw=3 ts=3 cc=85 cuc:

"## Statusline

set laststatus=2                " habilita statusline
set statusline=                 " reseta statusline
set statusline+=\ %f\ %r\%m\    " nome abreviado, readonly e modificado
set statusline+=\%=				" espa√ßo
set statusline+=\ %p%%\ %l:\%c  " rownumber, total e percentual
set statusline+=\ %y            " filetype

"## Autocomplete

set wildmenu                        " habilita menu
" https://vi.stackexchange.com/questions/5029/key-mapping-that-will-invoke-the-wildmenu
set wildcharm=<tab>                 " char para chamar wildmenu de um map
" set completeopt=menuone,noselect,noinsert    " mostra menu de op√ß√µes
" set completeopt=menu,menuone,noinsert
set completeopt=menuone,noinsert,noselect
" menuone: menu com uma ou mais de uma sugest√£o
" noinsert: n√£o insere texto selecionado automaticamente
" noselect: n√£o seleciona o texto automaticamente
set shortmess+=c                    " remove mensagens in√∫teis do wildmenu

" usa como separador de diret√≥rio '/' ao inv√©s de '\', padr√£o do windows
" muito utili para importar modulos no javascript
set shellslash " set nossl cancela

" Remove das sugest√µes arquivos/diretorios (lvimgrep tb)
" THANKS: https://stackoverflow.com/questions/1898987/how-to-exclude-file-patterns-in-vimgrep
set wildignore=node_modules/*
set wildignore+=.git/*
set wildignore+=dist/*
set wildignore+=vendor/*
set wildignore+=ios/*
set wildignore+=android/*
set wildignore+=_site/*

":h ins-completion
" origem das palavras do wildmenu:
"   - buffer corrente
"   - dicion√°rios
"   - de outras janelas (splits)
set complete=.,k,w
" sugest√£o de tags afeta perf
" <c-e> mantem o insert mode e fecha completeopt

" set tags=tags,./tags
set tags=tags

" sugere palavras com h√≠fen como font-size
" THANKS: https://stackoverflow.com/questions/25049838/make-autocomplpop-allow-hyphen-as-a-word-charcter
set iskeyword+=-

" escolhe palavras do omnifunc de acordo com o filetype do buffer aberto
" https://github.com/vim-scripts/SyntaxComplete
set omnifunc=syntaxcomplete#Complete    " <c-x><c-o>

"### Tabs/espa√ßos

" https://stackoverflow.com/questions/1878974/redefine-tab-as-4-spaces
set tabstop=4
set softtabstop=4
set shiftwidth=4
set smarttab
set expandtab

"## Fold

" m√©todo padr√£o de fold
set foldmethod=marker
set foldtext=FoldTextMarker()

" :h digraph-table-mbyte
set fillchars=vert:\|,fold:‚îÄ

" retorna t√≠tulo dos folds padr√£o marker com {{{}}}
" THANKS: https://stackoverflow.com/questions/5983396/change-the-text-in-folds
" THANKS: https://jdhao.github.io/2019/08/16/nvim_config_folding/
" THANKS: https://dhruvasagar.com/2013/03/28/vim-better-foldtext
function! FoldTextMarker()
  let lines_count = v:foldend - v:foldstart + 1

  " :h digraph-table-mbyte
  let lines_count_text = '‚î§' . printf("%4s", lines_count) . '‚îú'
  let foldchar = matchstr(&fillchars, 'fold:\zs.')

    " remove marca√ß√£o de coment√°rios # // /* <!--
    let titulo = substitute(getline(v:foldstart),"^[#*{\/ \"<!--]*","",'g')

    " remove marca√ß√£o de coment√°rios */
    let titulo = substitute(titulo,"\*\/*$","",'g')
    " remove marca√ß√£o de coment√°rios -->
    let titulo = substitute(titulo,"\-\-\>*$","",'g')
    " remove espa√ßos que sobraram ao final da linha
    let titulo = substitute(titulo,"\ *$","",'g')

  " cria + de acordo com # (foldlevel)
  let foldtextstart = repeat('+', v:foldlevel) . ' ' . titulo

  let foldtextend = lines_count_text . repeat(foldchar, 8)
  let foldtextlength = strlen(substitute(foldtextstart . foldtextend, '.', 'x', 'g')) + &foldcolumn
  return foldtextstart  . ' ' . repeat(foldchar, winwidth(0)-foldtextlength) . foldtextend
endfunction

"## Netrw
" Netrw no lugar do nerdtree, usar :Lexplore para toggle
" - :edit a folder to open a file browser
" - <CR>/v/t to open in an h-split/v-split/tab
" - check |netrw-browse-maps| for more mappings

"TODO Como n√£o criar NetrwTreeListing (???) e .netrwhist? (???)
" https://github.com/tpope/vim-vinegar/issues/13
" autocmd FileType netrw setlocal bufhidden=delete

"let g:netrw_banner=0        " disable annoying banner
"let g:netrw_browse_split=4  " open in prior window
" FIXME N√£o funciona de primeira
let g:netrw_liststyle=3     " tree view

" Exibe numeros (ruler)
" THANKS: https://stackoverflow.com/a/8731175
let g:netrw_bufsettings = 'noma nomod nu nobl nowrap ro'

"## Spell
" Corretor ortogr√°fico, ideal os filetypes: text, gitcommit e markdown

" COMANDOS:
"    ]s ‚Äî ir para a pr√≥xima palavra errada;
"    [s ‚Äî voltar para a palavra errada anterior;
"    zg ‚Äî adicionar a palavra sob o cursor ao dicion√°rio;
"    zug ‚Äî desfazer a adi√ß√£o;
"    z= ‚Äî ver sugest√µes de corre√ß√£o para esta palavra;

" lingua da checagem
" BR em capslock gera o aviso: Warning region not supported
set spelllang=pt_br

" local onde est√° o dicion√°rio
" THANKS: 
"   - https://github.com/vim/vim/issues/1330
"   - https://extensions.openoffice.org/en/project/vero-brazilian-portuguese-spellchecking-dictionary-hyphenator
"   - https://github.com/vim/vim/files/655099/pt_BR.diff.zip
"   - https://github.com/mateusbraga/vim-spell-pt-br
"   - https://ndvo.wordpress.com/2013/06/05/corretor-ortografico-nativo-do-vim/
"   - https://www.dicas-l.com.br/arquivo/verificacao_ortografica_com_o_editor_vim.php
"   - https://www.vivaolinux.com.br/artigo/Corretor-Ortografico-no-Vim-Guia-definitivo
" no momento n√£o tenho interesse em ficar versionando a adi√ß√£o de palavras
"execute "set rtp+=".g:dotfiles_dir."/vim/spell"

" arquivo que possui as adi√ß√µes do dicion√°rio
" THANKS: https://stackoverflow.com/a/27979576/9881278
execute "set spellfile=".g:dotfiles_dir."/vim/spell/pt.utf-8.add"
"## Fun√ß√µes
"### NN_
" Fun√ß√µes que s√£o usadas com frequencia n√£o t√£o alta para serem comandos ou
" maps, padr√£o NN_ para ficar f√°cil achar com :call NN_<tab>
" Fun√ß√µes muito usadas por√©m n√£o tanto a ponto de virarem comandos ou maps
" O padr√£o NN_ serve para ficar f√°cil achar com :call NN_<tab>

" Att ctags
" Necessario instalar ctags ou universal ctags
function! NN_ctags()
    let s:ctags_command="ctags" . 
                  \ " -R --totals" .
                  \ " --exclude=.git --exclude=.svn" .
                  \ " --exclude=vendor" .
                  \ " --exclude=node_modules --exclude=dist --exclude=build --exclude=ios --exclude=android" .
                  \ " --exclude=_site" .
                  \ " --languages=php,javascript"

    " procura se existe um arquivo .ctags a mais
    if filereadable(expand(".ctags"))
        let s:ctags_command.=" --options=.ctags"
    endif

    " seta pasta atual como alvo do ctags
    let s:ctags_command.=" ."

    " executa o comando montado na string
    execute "!".s:ctags_command
endfun


" habilita e desabilita emojis, ideal para perf
function! NN_EmojiToggle()
    if &renderoptions == ""
        set renderoptions=type:directx,gamma:1.0,contrast:0.1,level:1.0,geom:1,renmode:5,taamode:1
    else
        set renderoptions=
    endif
endfun

" atualiza diret√≥rio atual (:pwd) com dir do projeto, com raiz .git
" THANKS: https://michaelheap.com/set-parent-git-directory-to-current-path-in-vim/
function! NN_SetGitDir()
    " Change working dir to the current file
    cd %:p:h
    " Set 'gitdir' to be the folder containing .git
    let gitdir=system("git rev-parse --show-toplevel")
    " See if the command output starts with 'fatal' (if it does, not in a git repo)
    let isnotgitdir=matchstr(gitdir, '^fatal:.*')
    " If it empty, there was no error. Let's cd
    if empty(isnotgitdir)
        cd `=gitdir`
    endif
endfunction

" abre :Lexplorer com pwd como do git
" THANKS: https://michaelheap.com/set-parent-git-directory-to-current-path-in-vim/
function! NN_Lexplorer()
    call NN_SetGitDir()
    Lexplore
endfunction

" lista todos e fixmes tags
" THANKS: https://www.commandlinefu.com/commands/view/12833/get-a-list-of-all-todofixme-tasks-left-to-be-done-in-your-project
" OBS: Ir√° ignorar path do wildignore https://stackoverflow.com/a/20042050
" FIXME ativa :GitGutterToggle
fun! NN_Tasks()
    call NN_SetGitDir()
    "silent !git grep -EIn "TODO|FIXME"
    lvimgrep /\C\<TODO\>\|\C\<FIXME\>/j **
    lopen
endfun

" script para os meus commits padr√µes de aula
fun! NN_GitAula()
    let log = system("git log --pretty=format:\%s")
    vnew
    put=log
    normal! gg
    if search('^:tv: add aula')>0
        normal! 3W
        let s:numero_aula = expand('<cword>')+1
        echom system("git add -A && git commit -m \":tv: add aula ".s:numero_aula."\"")
    else
        echom system("git add -A && git commit -m \":tv: add aula 1\"")
    endif
    bdelete!
endfun

" script para os meus commits padr√µes do exercism.io
fun! NN_GitExercism()
    vnew | 0r!git status --porcelain
    normal! f"
    normal! wv3wh"gy
    execute "let s:desafio=\"".getreg('g')."\""
    execute "!git add -A && git commit -m \"release: add ".s:desafio."\""
    bdelete!
endfun
"#### Git
function NN_Git_add()
    echo "n√£o implementado!"
endfun

"### Private (script)
" Fun√ß√µes privadas que s√£o usadas unicamente no vimrc

" carrega arquivo se ele existe
" THANKS: https://devel.tech/snippets/n/vIIMz8vZ/load-vim-source-files-only-if-they-exist/
function! SourceIfExists(file)
  if filereadable(expand(a:file))
    exe 'source' a:file
	"else
	"echo "N√£o existe o arquivo:"  a:file
  endif
endfunction

"### Shared
" Fun√ß√µes que s√£o mapeadas, portanto n√£o devem ficar com NN_

" https://stackoverflow.com/questions/20933836/what-is-the-difference-between-location-list-and-quickfix-list-in-vim
" THANKS: https://github.com/jmharvey/vim/blob/master/vimrc#L207
" THANKS: https://vimrcfu.com/snippet/104
" FIXME Ativa gitguttertoggle
fun! Grep(grepword)
    call NN_SetGitDir()
    if len(a:grepword) == 0
        let s:grepword = input("Grep: ")        
    else
        let s:grepword = a:grepword
    endif
    "exec "silent !git grep -EIn \"" . grepword . "\""
    " exec "vimgrep /".s:kwd."/ %"|" No arquivo
    exec "lvimgrep /\\<" . s:grepword . "\\>/j **"
    lopen
endfun

" Fun√ß√£o utilizada para limpar a tela do terminal
" Dependendo do SO muda o comando...
fun! LimpaTerminal()
    if has("win32")
        silent !cls
    else
        silent !clear
    endif
endfun

" fecha split ou deleta o buffer
fun! FechaSplitOuDeletaBuffer()
    if winnr('$') > 1
        q
    else
        bd
    endif
endfun

" fecha split ou deleta o buffer ignorando modifica√ß√µes
fun! FechaSplitOuDeletaBufferForced()
    if winnr('$') > 1
        q!
    else
        bd!
    endif
endfun

" sugest√µes do :OutputAssertion
fun! ListExecutaveis(A,L,P)
    return "python3\nnode\ngo run\nlua"
endfun

" TODO desacoplar execu√ß√£o com cria√ß√£o da tab
fun! OutputAssertion(command)
    execute "tabnew | 0r!".a:command." #"

    " faz o vim entender que n√£o queremo salvar esse arquivo
    setlocal buftype=nofile
    normal! Gdd
    nnoremap <buffer> q :windo bd!<CR>
    new

    " deixar em cima a mensagem
    " caso tenha: set splitbelow
    " √© o ideal
    " wincmd r
    normal! iUse "q" para fechar todos os buffers

    " faz o vim entender que n√£o queremo salvar esse arquivo
    setlocal buftype=nofile
    wincmd w

    " resize o m√°ximo
    wincmd _

    vert diffsplit outputassertion.txt
    nnoremap <buffer> q :windo bd!<CR>
    wincmd l
endfun

"## Comandos

" recarrega vimrc com trigger para o filetype
" THANKS: https://vi.stackexchange.com/questions/9338/why-cannot-i-source-vimrc-for-the-current-file-being-editing
command! Sov source $MYVIMRC | e %

" fechar (sem for√ßar) todos buffers e deixar somente um
" THANKS: https://salferrarello.com/vim-close-all-buffers-except-the-current-one/
command! BufOnly execute 'kb|%bdelete|e #|b#|bd%|normal `b'

" abre terminal em split, ideal para o gvim
" FIXME n√£o funciona corretamente no linux
" THANKS: https://stackoverflow.com/a/38082196
command! TerminalGitRootVertical exec 'call NN_SetGitDir() | vert term ++kill=term'
command! TerminalGitRootHorizontal exec 'call NN_SetGitDir() | term ++kill=term'

command! Grep :call Grep("")<cr>

" Ver highlight-groups
"   :so $VIMRUNTIME/syntax/hitest.vim
" Ver highlight group da palavra sob o cursor
" https://vim.fandom.com/wiki/Identify_the_syntax_highlighting_group_used_at_the_cursor
" :highlight mostra as cores do grupo
command! Syntax echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<' . synIDattr(synID(line("."),col("."),0),"name") . "> lo<" . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"

command -complete=custom,ListExecutaveis -nargs=+ OutputAssertion :execute ":call OutputAssertion(\"<args>\")"

"## Mapeamentos

":map -> lista todos mapeamentos para o arquivo

" TODO ver funcionamento do localleader (:h maplocalleader)
let mapleader="\<space>"

nnoremap    <leader><leader>    :w<CR>
nnoremap    <leader><cr>        :call NN_Lexplorer()<cr>
nnoremap    <leader>/           :noh<cr>
nnoremap    <leader>.           :pwd<CR>
nnoremap    <leader>dd          :call FechaSplitOuDeletaBuffer()<CR>
nnoremap    <leader>df          :call FechaSplitOuDeletaBufferForced()<CR>
nnoremap    <leader>ds          :on<CR>| " Close all splits
nnoremap    <leader>n           :call NN_<tab><left>| " fun√ß√µes pessoais
nnoremap    <leader>s           :split<CR>
nnoremap    <leader>t           :tn <c-r><c-w><CR>| " Goto definition (ctags)
nnoremap    <leader>v           :vsplit<CR>
nnoremap    <leader>y           my^vg_"+y:echo "Copiado!!"<CR>
vnoremap    <leader>y           "+y:echo "Copiado!!"<CR>

nnoremap    #           :b #<CR>|" FIXME volta para unlisted buffer tbm
nnoremap    !!          :!!<CR>
vnoremap    <           <gv|" mant√™m select ap√≥s indenta√ß√£o
vnoremap    >           >gv|" mant√™m select ap√≥s indenta√ß√£o
inoremap    "           ""<left>|"autoclose
inoremap    '           ''<left>|"autoclose
inoremap    {           {}<left>|"autoclose
inoremap    {}          {}|"evitar {}}
inoremap    {<CR>       {}<left><CR><Esc>O|"autoclose
inoremap    {<space>    {}<left><space><space><left>|"autoclose
inoremap    (           ()<left>|"autoclose
inoremap    ()          ()|"evitar ())
inoremap    (<CR>       ()<left><CR><Esc>O|"autoclose
inoremap    (<space>    ()<left><space><space><left>|"autoclose
inoremap    [           []<left>|"autoclose
inoremap    []          []|"evitar []]
inoremap    [<CR>       []<left><CR><Esc>O|"autoclose
inoremap    [<space>    []<left><space><space><left>|"autoclose
vnoremap    J           :m '>+1<CR>gv=gv| " move sele√ß√£o pra baixo
vnoremap    K           :m '<-2<CR>gv=gv| " move sele√ß√£o pra cima
inoremap    kj          <esc>|" esc mais f√°cil
nnoremap    n           nzzzv|" centraliza match do search
nnoremap    N           Nzzzv|" centraliza match do search
vnoremap    o'          c'<c-r>"'|" surround match
vnoremap    o"          c"<c-r>""|" surround match
vnoremap    o(          c(<c-r>")|" surround match
vnoremap    o{          c{<c-r>"}|" surround match
vnoremap    o[          c[<c-r>"]|" surround match
nnoremap    Q           @q|" executa macro em 'q' (letra que mais gravo)
tnoremap    <esc>       <C-\><C-n>
noremap     \           za|" toggle fold
nnoremap    <expr><f2>  &foldlevel ? 'zM' :'zR'| " Toggle fold todo arquivo
noremap     <up>        <nop>|" for√ßa hjkl
noremap     <down>      <nop>|" for√ßa hjkl
noremap     <left>      <nop>|" for√ßa hjkl
noremap     <right>     <nop>|" for√ßa hjkl
inoremap    <up>        <nop>|" for√ßa hjkl
inoremap    <down>      <nop>|" for√ßa hjkl
inoremap    <left>      <nop>|" for√ßa hjkl
inoremap    <right>     <nop>|" for√ßa hjkl
nnoremap    <c-\>       <c-]>|" teclado brasileiro <c-]> n√£o funciona
inoremap    <c-a>       <C-O>yiW<End>=<C-R>=<C-R>0<CR>| " tip 73 (vim.fandom)
""nnoremap    <c-g>       viwy:call Grep("<c-r>0")<cr>|" grep palavra do cursor
""vnoremap    <c-g>       y:call Grep("<c-r>0")<cr>|" grep da sele√ß√£o
inoremap    <c-h>       <left>|" for√ßa hjkl
" nnoremap    <c-h>       <c-w>h
cnoremap    <c-h>       <left>
inoremap    <c-j>       <down>|" for√ßa hjkl
" nnoremap    <c-j>       <c-w>j
nnoremap    <c-j>       <c-w>w|" estilo DWM
" inoremap    <c-k>       <up>|" for√ßa hjkl
" nnoremap    <c-k>       <c-w>k
nnoremap    <c-k>       <c-w>W|" estilo DWM
" nnoremap    <c-l>       <c-w>l
cnoremap    <c-l>       <right>
inoremap    <c-l>       <right>|" for√ßa hjkl
tnoremap    <c-l>       cls<cr>
nnoremap    <c-n>       yiwV| " substitue mult cursors
xnoremap    <c-n>       :s/<c-r><c-*>//g<left><left>| " substitue mult cursors
inoremap    <c-q>       <esc>:call JumpToTag()<cr>| " <++>
nnoremap    <c-q>       :call JumpToTag()<cr>| " <++>
nnoremap    <c-s>       mi<esc>gg=G`i|" indenta todo o arquivo
nnoremap    <c-z>       u|" remove comportamento <c-z>
tnoremap    <s-insert>  <c-w>"*
tnoremap    <c-s-v>     <c-w>"*

"## Abrevia√ß√µes

cnoreabbrev W! w!
cnoreabbrev Q! q!
cnoreabbrev Qa! qa!
cnoreabbrev QA! qa!
cnoreabbrev Wq wq
cnoreabbrev Wa wa
cnoreabbrev wQ wq
cnoreabbrev WQ wq
cnoreabbrev W w
cnoreabbrev Q q
cnoreabbrev Qa qa
cnoreabbrev QA qa
cnoreabbrev Wqa wqa
cnoreabbrev WQa wqa
cnoreabbrev WQA wqa
cnoreabbrev wQA wqa
cnoreabbrev wqA wqa
cnoreabbrev wQa wqa

" THANKS: https://vim.fandom.com/wiki/Find_in_files_within_Vim
cabbrev lvim
      \ noautocmd lvim /\<lt><C-R><C-W>\>/gj
      \ **<C-R>=(expand("%:e")=="" ? "" : ".".expand("%:e"))<CR>
      \ <Bar> lw
      \ <C-Left><C-Left><C-Left>

"## AutoCmds

"https://vi.stackexchange.com/questions/9455/why-should-i-use-augroup
"augroup tempos
"    autocmd InsertEnter * set timeoutlen=700
"    autocmd InsertLeave * set timeoutlen=1000
"augroup END

"### ftdetect

"https://www.reddit.com/r/vim/wiki/where_to_put_filetype_specific_stuff
"FIXME Como colocar defini√ß√£o de filetype em ftdetect?
augroup filetype_detect
    au!
    au BufRead,BufNewFile *.phtml setfiletype html
    au BufRead,BufNewFile *.hbs setfiletype html
    au BufRead,BufNewFile *.gv setfiletype dot
augroup END

"## packs pessoais
" Funcionalidades que podem virar mini packages/plugins.
" Alguns podem estar em packages.vim
"### Highlight Word
" Colore palavras (como se fosse o search)
" Antes do pack: 
" nnoremap    <kMultiply> *N| "https://stackoverflow.com/a/24537701
" THANKS: https://bitbucket.org/sjl/dotfiles/raw/d8f861e3276a89c0f98637725006da658adcda90/vim/vimrc

function! HiInterestingWord(n)
    " Defini√ß√£o do highlight, por algum motivo pelo vimrc n√£o ocorre
    hi def InterestingWord1 guifg=#000000 ctermfg=16 guibg=#ffa724 ctermbg=214
    hi def InterestingWord2 guifg=#000000 ctermfg=16 guibg=#aeee00 ctermbg=154
    hi def InterestingWord3 guifg=#000000 ctermfg=16 guibg=#8cffba ctermbg=121
    hi def InterestingWord4 guifg=#000000 ctermfg=16 guibg=#b88853 ctermbg=137
    hi def InterestingWord5 guifg=#000000 ctermfg=16 guibg=#ff9eb8 ctermbg=211
    hi def InterestingWord6 guifg=#000000 ctermfg=16 guibg=#ff2c4b ctermbg=195

    " Save our location.
    normal! mz

    " Yank the current word into the z register.
    normal! "zyiw

    " Calculate an arbitrary match ID.  Hopefully nothing else is using it.
    let mid = 86750 + a:n

    " Clear existing matches, but don't worry if they don't exist.
    silent! call matchdelete(mid)

    " Construct a literal pattern that has to match at boundaries.
    let pat = '\V\<' . escape(@z, '\') . '\>'

    " Actually match the words.
    call matchadd("InterestingWord" . a:n, pat, 1, mid)

    " Move back to our original location.
    normal! `z
endfunction

" TODO remover/resetar um ou todos highlights
nnoremap <leader>1 :call HiInterestingWord(1)<cr>
nnoremap <leader>2 :call HiInterestingWord(2)<cr>
nnoremap <leader>3 :call HiInterestingWord(3)<cr>
nnoremap <leader>4 :call HiInterestingWord(4)<cr>
nnoremap <leader>5 :call HiInterestingWord(5)<cr>
nnoremap <leader>6 :call HiInterestingWord(6)<cr>

"### Coment√°rio
" THANKS: https://stackoverflow.com/a/24046914
let s:comment_map = { 
            \   "c": '\/\/',
            \   "cpp": '\/\/',
            \   "dot": '\/\/',
            \   "go": '\/\/',
            \   "java": '\/\/',
            \   "javascript": '\/\/',
            \   "javascriptreact": '\/\/',
            \   "typescript": '\/\/',
            \   "typescriptreact": '\/\/',
            \   "lua": '--',
            \   "scala": '\/\/',
            \   "php": '\/\/',
            \   "python": '#',
            \   "ruby": '#',
            \   "rust": '\/\/',
            \   "sh": '#',
            \   "desktop": '#',
            \   "fstab": '#',
            \   "conf": '#',
            \   "profile": '#',
            \   "bashrc": '#',
            \   "bash_profile": '#',
            \   "mail": '>',
            \   "eml": '>',
            \   "bat": 'REM',
            \   "ahk": ';',
            \   "vim": '"',
            \   "tex": '%',
            \ }

function! ToggleComment()
    if has_key(s:comment_map, &filetype)
        let comment_leader = s:comment_map[&filetype]
        if getline('.') =~ "^\\s*" . comment_leader . " " 
            " Uncomment the line
            execute "silent s/^\\(\\s*\\)" . comment_leader . " /\\1/"
        else 
            if getline('.') =~ "^\\s*" . comment_leader
                " Uncomment the line
                execute "silent s/^\\(\\s*\\)" . comment_leader . "/\\1/"
            else
                " Comment the line
                execute "silent s/^\\(\\s*\\)/\\1" . comment_leader . " /"
                " execute "silent s/^/\\1" . comment_leader . " /"
            end
        end
    end
endfunction

nnoremap gcc :call ToggleComment()<cr>
vnoremap gcc :call ToggleComment()<cr>

"### Snippets

" modelo de snippet
" DEMO: snip<space> 
inoreabbrev <expr> snip TestaTriggerSnippet('fir',
            \ "snip(let i=0;x > 10;x++){<cr>/* codigo */<cr>}",
            \ ['let i=0', 'x > 10', 'x++', '\/\* codigo \*\/'])

fun! TestaTriggerSnippet(abbr, expansion, placeholders)
    let g:placeholders = a:placeholders
    let s:expansion = a:expansion.
                \ "\<Esc>:call PlaceHolder('?')\<CR>"
                " \ "\<Esc>g_"
                " \ "\<C-R>=Eatchar('\s')\<CR>"
    let c = nr2char(getchar(0))
    if c == g:nonkw_snippet_trigger
        return s:expansion
    else
        return a:abbr . c
    endif
endfun

" impede espa√ßo da abrevia√ß√£o no conteudo abreviado
"THANKS: :h abbreviation
""func Eatchar(pat)
""    let c = nr2char(getchar(0))
""    return "\<right>"
""    " FIXME acionar somente com espa√ßo...
""    " return (c =~ a:pat) ? '' : c
""endfunc

inoremap <c-j> <ESC>:call PlaceHolder('/')<CR>
snoremap <c-j> <ESC>:call PlaceHolder('/')<CR>
snoremap <bs>  i<bs>

" TODO tornar stateless
let g:placeholders = []
func! PlaceHolder(backward)
    if get(g:placeholders, 0, '0') != '0'
        if search(g:placeholders[0], 'nw')>0
            let placeholder = g:placeholders[0]
            unlet g:placeholders[0]

            if get(g:placeholders, 0, '0') != '0'
                highlight link NeniSnippetPlaceHolder DiffAdd
                execute 'match NeniSnippetPlaceHolder /'.g:placeholders[0].'/'
            else
                execute "match NeniSnippetPlaceHolder //"
            endif

            execute "normal! ".a:backward.placeholder."\<cr>"
            execute "normal! gn\<c-g>"
        else
            execute "normal! a".g:placeholders
        endif
    endif
endfun

" snippet + \
let g:nonkw_snippet_trigger = "\<space>"

" OBJETIVO: "Desabilita" abrevia√ß√£o.
" Ao inv√©s de desabilitar, se for usado <c-v> no insert-mode o pr√≥ximo char
" n√£o ativa a abrevia√ß√£o
command! AbbrevToggle if g:nonkw_snippet_trigger=="\\"
            \|let g:nonkw_snippet_trigger="\<space>"
            \|else|let g:nonkw_snippet_trigger="\\"|endif

" OBJETIVO: Prompt de confirma√ß√£o para expandir abrevia√ß√£o.
" DEMO: snippet + non-keyword + <cr>
" THANKS: Hacking Vim 7.2 (packt)
""function! AbbrAsk(abbr,expansion)
""    let s:expansion = a:expansion.
""                \ "\<Esc>:call search('!cursor!','b')\<cr>cf!".
""                \ "\<Left>\<C-R>=Eatchar('\s')\<CR>"
""    if g:abbrevEnabled == 1
""        let answer = confirm("Use the abbreviation '" . a:abbr . "'?", "&Yes\n&No", 1) 
""        return answer == 1 ? s:expansion : a:abbr
""    else
""        return a:abbr
""    endif
""endfunction
""
""let g:abbrevEnabled = 1
""command! AbbrevToggle :call AbbrevToggle()
""" ao inv√©s de desabilitar, se for usado <c-v> no insert-mode o pr√≥ximo char
""" n√£o ativa a abrevia√ß√£o
""fun! AbbrevToggle()
""    if g:abbrevEnabled == 1
""        let g:abbrevEnabled = 0
""    else
""        let g:abbrevEnabled = 1
""    endif
""endfun

" OBJETIVO: <tab> para listar omni se houver, dicion√°rio ou buffer complete.
" √â util mas existem situa√ß√µes que eu sei que a vari√°vel existe
" e quero utilizar seu nome
" THANKS: Hacking Vim 7.2 (packt)
""function! s:superCleverTabOmni()
""    if strpart( getline('.'), 0, col('.')-1 ) =~ '^\s*$'
""        return "\<Tab>" 
""    else
""        " do we have omni completion available
""        if &omnifunc != '' 
""            "use omni-completion 1. priority
""            return "\<C-X>\<C-O>"  
""        elseif &dictionary != '' 
""            " no omni completion, try dictionary completio
""            return "\<C-K>" 
""        else
""            "use omni completion or dictionary completion  
""            "use known-word completion  
""            return "\<C-N>"  
""        endif  
""    endif
""endfunction
""" bind function to the tab key
""inoremap <Tab> <C-R>=SuperCleverTab()<cr>

" OBJETIVO: Usar <tab> quando tiver menu como <c-n>.
" Prefiro manter o padr√£o vim...
" THANKS: https://gist.github.com/maxboisvert/a63e96a67d0a83d71e9f49af73e71d93
""inoremap <expr> <Tab> TabComplete()
""fun! TabComplete()
""    if getline('.')[col('.') - 2] =~ '\K' || pumvisible()
""        return "\<C-P>"
""    else
""        return "\<Tab>"
""    endif
""endfun
""inoremap <expr> <Tab> TabComplete()
    
" TODO listagem de snippets...
""inoremap <c-s> <c-r>=ListMonths()<CR>
""func! ListMonths()
""    call complete(col('.'), ['January', 'February', 'March',
""                \ 'April', 'May', 'June', 'July', 'August', 'September',
""                \ 'October', 'November', 'December'])
""    return ''
""endfunc
"#### Listas
" THANKS: :h complete()
func! AutoCompleteCarinhas()
    call complete(col('.'), [
                \ '‡≤•_‡≤•',
                \ '·Éö(‡≤†Áõä‡≤†·Éö)',
                \ '‡≤†‚ï≠‚ïÆ‡≤†',
                \ '(‚ïØ¬∞‚ñ°¬∞)‚ïØÔ∏µ  ûooq«ù…î…ê…ü',
                \ '(‚ïØ¬∞‚ñ°¬∞)‚ïØÔ∏µ ‚îª‚îÅ‚îª',
                \ '(‚ïÆ¬∞-¬∞)‚ïÆ‚î≥‚îÅ‚î≥',
                \ '( Õ°¬∞ Õú ñ Õ°¬∞)',
                \ '¬Ø\_(„ÉÑ)_/¬Ø',
                \ '(~Àò‚ñæÀò)~',
                \ '·ï¶(√≤_√≥Àá)·ï§',
                \])
    return ''
endfunc
inoremap <c-z> <c-r>=AutoCompleteCarinhas()<CR>
"#### snippets sem selectmode
"inoreabbrev <expr> for AbbrAsk('for',
"            \ "for(!cursor!;<+++>;<+++>){<cr><+++><cr>}")
"
" THANKS: Hacking Vim 7.2 (packt)
" procura <+++>
" inoremap <c-j> <ESC>/<+.\{-1,}+><cr>vf><c-g>
" snoremap <c-j> <ESC>/<+.\{-1,}+><cr>vf><c-g>
" snoremap <c-k> <esc>"_X"_x?<+<CR>2"_xi
" remove laterais <+ +>
"#### Antigo m√©todo de snippet
" Implementa√ß√£o
""inorea <buffer> dd <esc>:call TestaTriggerSnippet('dd', 'SnippetPhpDieDump')<cr>
""fun! SnippetPhpDieDump()
""    normal! ivar_dump();die;
""    normal! ==5h
""    startinsert
""endfun

" base
""highlight link NeniTagJump DiffAdd
""match NeniTagJump /<++>/
""function! JumpToTag()
""    " search retorna a linha onde o parametro foi encontrado
""    if search("<++>",'nw') > 0
""        " posiciona o cursor sob o padr√£o da marca√ß√£o
""        call search("<++>",'w')
""        " Caso a marca√ß√£o esteja na ultima coluna da linha, o :startinsert
""        " recua uma coluna a mais. Como seria muito complexo calcular essa
""        " situa√ß√£o, √© mais f√°cil entrar no modo de insert e apagar o numero
""        " de letras (4 para <++>)
""        call feedkeys("i\<del>\<del>\<del>\<del>")
""    endif
""endfun
""fun! TestaTriggerSnippet(root, func1)
""    let c = nr2char(getchar(0))
""    if c == "\<tab>"
""        let s:snippetfunc = function(a:func1)
""        noautocmd let @x = s:snippetfunc()
""        " :noautocmd cancela insertcharpre (e todos outros autocmds) para n√£o
""        " atrapalhar eventos de autocomplete com :normal! e etc
""    elseif c == "\<esc>"
""        execute "normal! a" . a:root . 'a'
""        execute 'normal! "_x'
""    else
""        " execute "normal a".a:root.c
""        execute "normal! a" . a:root . '"' . c
""        execute 'normal! h"_x'
""        startinsert
""        call cursor( line('.'), col('.') + 1)
""    endif
""endfun

"## sources
":scriptnames para ver a orderm e quais scripts foram iniciados

call SourceIfExists(g:dotfiles_dir."/vim/dotfiles.vim")
call SourceIfExists(g:dotfiles_dir."/vim/packages.vim")

"### local
" ideal para importar pythonthreehome e pythonthreedll
call SourceIfExists("~/.vimrc-local.vim")

"#### Sugest√µes para o vimrc-local
"
"" configura√ß√£oes que afetam a perf, mistura vim builtin e plugins
" call SourceIfExists(g:dotfiles_dir."/vim/plus.vim")
"
" let g:startify_lists = [
"             \ { 'type': 'sessions', 'header': ['sess√µes'] },
"             \ { 'type': 'commands', 'header': ['comandos'] },
"             \ ]
" 
" let g:startify_commands = [
"             \ {'g': ['gostack11', 'e ~/dev/gostack11']},
"             \ ]

"### pwd
" carrega vimrc se existente em no work dir (:h :pwd :h 'getcwd()')
" ideal para setar wildignore para remover pesquisa de paths de libs
" TODO remover source quando outro .exrc for carregado
au DirChanged * :call SourceIfExists(fnamemodify('.exrc', ":p"))
" exrc n√£o resolve o problema pois ele s√≥ carrega o .vimrc .exrc _vimrc ou
" _exrc no momento que o vim √© aberto no diret√≥rio, ou seja, o startify n√£o da
" o gatilho, mas √© uma op√ß√£o legal
"set exrc
"set secure
" THANKS: https://superuser.com/a/532673

