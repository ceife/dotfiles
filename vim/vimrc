" Arquivo de configura√ß√µes b√°sicas do vim, podendo ser adicionado de maneira
" independente do repo dotfiles. Basta copiar o conte√∫do para o
" %userprofile%\_vimrc no Windows ou $HOME/.vimrc no Linux.
" Tamb√©m pode testar essas configura√ß√µes com:
"   - vim -u <path/to/vimrc>
"
" AUTHOR: Neni @nenitf <http://neni.dev>
" SOURCE: https://raw.githubusercontent.com/nenitf/dotfiles/main/vim/vimrc
"
" INCENTIVO:    ‚îÇ
"               ‚îú(+) simplicidade
"               ‚îú(-) manuten√ß√£o
"               ‚îú(+) performance
"               ‚îú(+) estudo objetivo
"               ‚îú(+) qualidade de c√≥digo
"               ‚îú(-) bug em produ√ß√£o
"               ‚îî(+) üéâüéâüéâ
"
" PRECEITOS:
"   - Focar em perf windows e linux
"   - Organizar o trecho de c√≥digo no fold correto
"   - Manter o KISS, n√£o reescrever o vim! Lembrar que:
"       - A configura√ß√£o ser√° usada crossplatform (windows e linux)
"       - De boa usar terminal ao lado do vim, nem tudo tem que ser como emacs
"   - Manter compatibilidade entre vim e nvim
"   - Evitar trocar comandos default do teclado
"   - Usar/configurar a menor quantidade de plugins poss√≠vel
"   - Comentar/documentar bastante o c√≥digo (respeitando a largura de coluna)
"       - Configura√ß√µes antigas, novas, defaults e explica√ß√µes
"
" UPGRADES: Ver arquivo wiki/vim.md
"
" DICAS:
"   - Usar K (:h K) em cima da palavra da configura√ß√£o para consultar manual
"   - Nos folds:
"       - zR e zM abre e fecha recursivamente todo arquivo (map: <f2>)
"       - za abre e fecha (toggle) um folder (map: <tab>)
"       - [z ]z gg G de um fold aberto
"       - zj zk pulo de fold
"   - Propriedades que s√£o setadas podem voltar ao seu valor inicial com &,
"   por exemplo set wildmenu&
"   - Formatar largura dos coment√°rios com Vgq (por causa do formatoptions+=t)
"   - Comandos para testar perf:
"       - :syntime on e :syntime report
"       - abrir vim no terminal com vim --startuptime tempo.txt tempo.txt
"       - abrir vim no terminal com vim -u NONE (remove vimrc)
"
"## Vari√°veis
let g:dotfiles_dir = "~/dev/dotfiles"
let g:vimwikis_dirs = [
            \ g:dotfiles_dir."/wiki",
            \ g:dotfiles_dir."/wiki/vim"
            \ ]

if filereadable(expand("~/.vimrc-pre.vim"))
    execute 'source ~/.vimrc-pre.vim'
    " Sugest√µes para o vimrc-pre.vim
    " set pythonthreehome=~/AppData/Local/Programs/Python/Python38-32
    " set pythonthreedll=~/AppData/Local/Programs/Python/Python38-32/python38.dll
endif

"## B√°sico
" M√≠nimas configura√ß√µes para usar o vim

" quebra compatibilidade com vi
" evita erros bizarros como de interpreta√ß√£o de dicion√°rios e etc
set nocompatible

"### Conte√∫do
set encoding=utf-8
" TODO entender configs abaixo:
"set fileencoding=utf-8 "?
"set fileencodings=utf-8 "?

set fileformats=unix,dos,mac "?
" TODO entender configs abaixo:
"set bomb "?
"set binary "?

" ^M, n√£o sei como resolvi ainda!
" THANKS: https://stackoverflow.com/questions/6496778/vim-run-autocmd-on-all-filetypes-except
"fun! Dos2unix()
"    " Don't strip on these filetypes
"    " :echo &ft
"    if &ft =~ 'startify\|nerdtree'
"        return
"    endif
"    :e ++ff=dos
"endfun
" autocmd BufRead * call Dos2unix()

"### Vim n√£o-bloqueante
" checar/atualizar quando o texto for modificado (ocorre mt com o git)
set autoread
autocmd FocusGained,BufEnter * :silent!<space>!
" au FocusGained,BufEnter * checktime

"### RuntimePaths
" Deve vir antes das defini√ß√µes de filetype
" carrega ftdetect, para definir extens√µes de tipos de arquivos
execute "set runtimepath+=".g:dotfiles_dir."/vim"
" evita autocmd de highligh (syntax/) e espec√≠ficas do filetype (ftplugin/)
execute "set runtimepath+=".g:dotfiles_dir."/vim/after"

" O vim utilizado pelo git para commitar no Windows √© diferente do que fica
" instalado no sistema. Portanto o mesmo n√£o procura em ~/vimfiles/pack/ os
" packages (plugins), mas sim em ~/.vim (padr√£o Linux).
" Como solu√ß√£o basta adicionar manualmente. Aparentemente n√£o tem problema em
" escolher duas vezes o mesmo diret√≥rio (caso seja aberto o gvim ao inv√©s de
" commitar por exemplo).
" Pode setar packpath ao inv√©s do runtimepath como solu√ß√£o
" THANKS: https://superuser.com/a/1466466
"set runtimepath+=~/vimfiles/pack/*/start/*
set packpath+=~/vimfiles

"### Syntax e indenta√ß√£o
" syntax de acordo com o filetype
" TODO diferen√ßa entre on e enabled
" syntax on
syntax enable

" carrega ftplugin.vim e indent.vim do runtimepath (plugins)
filetype plugin indent on

" permite usar <bs> mesmo indo contra auto-intent, eol e inicio da linha
" https://vi.stackexchange.com/questions/2162/why-doesnt-the-backspace-key-work-in-insert-mode
set backspace=indent,eol,start

"### Apar√™ncia e som
" colorscheme default, sobescrito com plugins
colorscheme slate
" ajusta cores para um fundo escuro
set background=dark
" for√ßa uso de 256 cores, permitindo highlight hexadecimal, com guibg e guifg
" ao inv√©s de somente ctermbg e ctermfg
set t_Co=256
set termguicolors

" Remove som ao apertar multiplos ESCs
" https://vim.fandom.com/wiki/Disable_beeping"
set noerrorbells novisualbell t_vb=
set belloff=all " cancela v√°rios beeps, incluindo <esc><esc>

" habilita conceal
set conceallevel=2

"#### Syntax e Highlight"
":verbose highlight <highlightGroup>

" Corrige highlights padr√µes
" Caso seja necess√°rio corrigir syntax de um plugin, deve ser feito em packages.vim

function FixHighlight()
    highlight link typescriptDOMDocProp typescriptProp
    highlight link typescriptPaymentShippingOptionProp typescriptProp
    highlight link typescriptPaymentMethod typescriptProp
    highlight link typescriptDOMEventProp typescriptProp

    highligh link gitcommitSummary gitcommitFirstLine

    " highlight SpellBad term=underline gui=undercurl guisp=Orange
    highlight SpellBad guifg=#000000 guibg=#af0000 gui=bold term=bold ctermfg=black ctermbg=red
endfun

augroup override_highlights
    autocmd!
    autocmd ColorScheme * call FixHighlight()
augroup END

"## Comportamento
set showmatch                   " exibe fechamento de {[()]}
set showmode                    " exibe mode no canto inferior esquerdo
set showcmd                     " exibe os comandos no canto inferior direito
set autoindent                  " auto indenta√ß√£o
set mouse=                      " restringe uso do mouse em todos modos ("a" libera)
set linebreak                   " quebra a linha por palavra e n√£o por letra
set nocursorcolumn nocursorline " n√£o marca colunha e linha do cursor (perf)
set number norelativenumber     " exibe r√©gua sem numero relativo (perf)
set nrformats-=octal            " ctrl-a ctrl -x
set lazyredraw                  " n√£o redesenha a tela durante macro (perf)
set nobackup                    " n√£o cria arquivo de bkp
set noswapfile                  " n√£o cria arquivo swap (?)
set scrolloff=3                 " mant√™m 3 linhas acima/abaixo do cursor em scroll
"set splitbelow                  " cria split horizontal abaixo (help estranho)
"set splitright                  " cria split vertical abaixo

" utiliza clipboard do linux e windows para copiar e colar (y e p)
set clipboard^=unnamedplus,unnamed

" Limite de coluna, comentado para ser posto em modelines espec√≠ficas
" set textwidth=80            " define largura da linha de texto
set colorcolumn=              " n√£o marca coluna (perf)
" set colorcolumn=81          " marca coluna 81, ideal para impress√£o com :ha
"                             " interessante deixar na modeline com cc

" Op√ß√µes de auto inser√ß√£o de blocos. Alguns filetypes j√° possuem
" por default diferentes configura√ß√µes, portanto √© mais interessante add ou
" remover (+= e -=). Abaixo os valores poss√≠veis (:h fo-table)
" t     quebra automatica do texto de acordo com textwidth
"       ideal colocar na modeline: tw=80 fo+=t
" c     quebra autom√°tica do texto de coment√°rios
" r     insere marca√ß√£o de coment√°rio (:set comments?) quando usado <cr> no
"       insert a partir de um coment√°rio
" o     insere marca√ß√£o de coment√°rio ao criar nova linha com 'o' no normal
" q     permite formata√ß√£o com Vgq (depende do textwidth)
" w     TODO
" a     TODO
" n     add automaticamente 2) 3) 4) ...
" v     TODO
" b     TODO
" l     n√£o quebra linhas que ao entrar no insert ja passaram o textwidth
" m     TODO
" M     TODO
" B     TODO
" 1     TODO
" j     ao juntar linhas de coment√°rios com 'J' remove o caracter de
"       coment√°rio intermedi√°rio
" p     TODO
set formatoptions+=jcr

" Buffers
" Motivos para usar buffers em segundo plano ao inv√©s de tabs:
"   - o mesmo arquivo n√£o √© aberto duas vezes
"   - mais velocidade pois a janela n√£o precisa ser redesenhada
set hidden " mant√™m o arquivo dispon√≠vel ao sair dele (mesmo modificado)
" :ls lista, :b <numero><tab> acessa buffers

" Pesquisa
set hlsearch    " colore os matches de search (* / %s)
set incsearch   " vai colorindo a pesquisa durante a digita√ß√£o
set ignorecase  " ignora case sensitive na busca
set nosmartcase " case sensitive se a primeira letra for maiuscula,
"               " ruim para autocomplete de nomes de fun√ß√µes

" Emojis coloridos
"if has("directx")
"    " renderiza emojis, afeta perf
"    " Para ativar basta usar :call NN_ToggleEmoji
"    set renderoptions=type:directx,gamma:1.0,contrast:0.1,level:1.0,geom:1,renmode:5,taamode:1
"    set emoji " ??? noemoji
"endif
set noemoji " (perf)
set renderoptions= " (perf)

" t√≠tulo da janela
"set title
"set titlestring=%<%F

"## Modeline
set modeline        " habilita uso da modeline
set modelines=5     " procura as 5 primeiras ou ultimas linhas do arquivo

" Exemplos de modeline (pode ser em coment√°rio):
" vim: set fdm=marker:
" vim: set fo+=t tw=80:
" vim: set sw=3 ts=3 cc=85 cuc:

"## Statusline
set laststatus=2                " habilita statusline
set statusline=                 " reseta statusline
set statusline+=\ %f\ %r\%m\    " nome abreviado, readonly e modificado
set statusline+=\%=				" espa√ßo
set statusline+=\ %p%%\ %l:\%c  " rownumber, total e percentual
set statusline+=\ %y            " filetype
set statusline+=\ {%n}          " buffer, ideal para conflitos do git com :diffget e :diffput

"## Autocomplete
set wildmenu         " habilita menu
set shortmess+=c     " remove mensagens in√∫teis do wildmenu

" THANKS: https://vi.stackexchange.com/questions/5029/key-mapping-that-will-invoke-the-wildmenu
set wildcharm=<tab>  " char para chamar wildmenu de um map

set completeopt=menuone,noinsert,noselect
" set completeopt=menuone,noselect,noinsert    " mostra menu de op√ß√µes
" set completeopt=menu,menuone,noinsert
" menuone: menu com uma ou mais de uma sugest√£o
" noinsert: n√£o insere texto selecionado automaticamente
" noselect: n√£o seleciona o texto automaticamente

" Usa como separador de diret√≥rio '/' ao inv√©s de '\', padr√£o do windows
" muito util para importar modulos no javascript
set shellslash " set nossl cancela

" Remove das sugest√µes arquivos/diretorios (lvimgrep tb)
" THANKS: https://stackoverflow.com/questions/1898987/how-to-exclude-file-patterns-in-vimgrep
set wildignore=node_modules/*
set wildignore+=.git/*
set wildignore+=dist/*
set wildignore+=vendor/*
set wildignore+=ios/*
set wildignore+=android/*
set wildignore+=_site/*

":h ins-completion
" origem das palavras do wildmenu:
"   - . buffer corrente
"   - k dicion√°rios
"   - w de outras janelas (splits)
set complete=.,k,w
" sugest√£o de tags afeta perf
" <c-e> mantem o insert mode e fecha completeopt

" Informa aquivo de tags
" set tags=tags,./tags
set tags=tags

" Configura palavras-com-hifen como palavras inteiras
" THANKS: https://stackoverflow.com/questions/25049838/make-autocomplpop-allow-hyphen-as-a-word-charcter
" PROS:
"   - CSS: font-size
" CONS:
"   - PHP: $this-> cria sugest√£o de $this-
set iskeyword+=-

" Escolhe palavras do omnifunc de acordo com o filetype do buffer aberto
" THANKS: https://github.com/vim-scripts/SyntaxComplete
set omnifunc=syntaxcomplete#Complete    " <c-x><c-o>

"### Tabs/espa√ßos
" https://stackoverflow.com/questions/1878974/redefine-tab-as-4-spaces
set tabstop=4
set softtabstop=4
set shiftwidth=4
set smarttab
set expandtab

"## Fold
" Add m√©todo padr√£o de fold
set foldmethod=marker " {{{ ... }}}
set foldtext=FoldTextMarker() " Configura t√≠tulo do fold fechado

" Configura s√≠mbolos do vim (:h digraph-table-mbyte)
set fillchars=vert:\|,fold:‚îÄ

" Retorna t√≠tulo dos folds sem coment√°rios padr√µes de linguagens
" THANKS: https://stackoverflow.com/questions/5983396/change-the-text-in-folds
" THANKS: https://jdhao.github.io/2019/08/16/nvim_config_folding/
" THANKS: https://dhruvasagar.com/2013/03/28/vim-better-foldtext
function! FoldTextMarker()
    let lines_count = v:foldend - v:foldstart + 1

    " :h digraph-table-mbyte
    let lines_count_text = '‚î§' . printf("%4s", lines_count) . '‚îú'
    let foldchar = matchstr(&fillchars, 'fold:\zs.')

    " remove marca√ß√£o de coment√°rios # // /* <!--
    let titulo = substitute(getline(v:foldstart), "^[#*{\/ \"<!--]*", "", 'g')

    " remove marca√ß√£o de coment√°rios */
    let titulo = substitute(titulo, "\*\/*$", "", 'g')
    " remove marca√ß√£o de coment√°rios -->
    let titulo = substitute(titulo, "\-\-\>*$", "", 'g')
    " remove espa√ßos que sobraram ao final da linha
    let titulo = substitute(titulo, "\ *$", "", 'g')

    " cria + de acordo com foldlevel
    let foldtextstart = repeat('+', v:foldlevel) . ' ' . titulo

    let foldtextend = lines_count_text . repeat(foldchar, 8)
    let foldtextlength = strlen(substitute(foldtextstart . foldtextend, '.', 'x', 'g')) + &foldcolumn
    return foldtextstart  . ' ' . repeat(foldchar, winwidth(0)-foldtextlength) . foldtextend
endfunction

"## Netrw
" Netrw no lugar do nerdtree, usar :Lexplore para toggle
" - :edit a folder to open a file browser
" - <CR>/v/t to open in an h-split/v-split/tab
" - check |netrw-browse-maps| for more mappings

" TODO Como n√£o criar NetrwTreeListing (???) e .netrwhist? (???)
" https://github.com/tpope/vim-vinegar/issues/13
" autocmd FileType netrw setlocal bufhidden=delete

"let g:netrw_banner=0        " disable annoying banner
"let g:netrw_browse_split=4  " open in prior window
" FIXME N√£o funciona de primeira
let g:netrw_liststyle=3     " tree view

" Exibe numeros (ruler)
" THANKS: https://stackoverflow.com/a/8731175
let g:netrw_bufsettings = 'noma nomod nu nobl nowrap ro'

"## Spell
" Corretor ortogr√°fico, ideal os filetypes: text, gitcommit e markdown

" COMANDOS:
"    ]s ‚Äî ir para a pr√≥xima palavra errada;
"    [s ‚Äî voltar para a palavra errada anterior;
"    zg ‚Äî adicionar a palavra sob o cursor ao dicion√°rio;
"    zug ‚Äî desfazer a adi√ß√£o;
"    z= ‚Äî ver sugest√µes de corre√ß√£o para esta palavra;

" lingua da checagem
" BR em capslock gera o aviso: Warning region not supported
set spelllang=pt_br

" local onde est√° o dicion√°rio
" THANKS: 
"   - https://github.com/vim/vim/issues/1330
"   - https://extensions.openoffice.org/en/project/vero-brazilian-portuguese-spellchecking-dictionary-hyphenator
"   - https://github.com/vim/vim/files/655099/pt_BR.diff.zip
"   - https://github.com/mateusbraga/vim-spell-pt-br
"   - https://ndvo.wordpress.com/2013/06/05/corretor-ortografico-nativo-do-vim/
"   - https://www.dicas-l.com.br/arquivo/verificacao_ortografica_com_o_editor_vim.php
"   - https://www.vivaolinux.com.br/artigo/Corretor-Ortografico-no-Vim-Guia-definitivo
" no momento n√£o tenho interesse em ficar versionando a adi√ß√£o de palavras
"execute "set runtimepath+=".g:dotfiles_dir."/vim/spell"

" arquivo que possui as adi√ß√µes do dicion√°rio
" THANKS: https://stackoverflow.com/a/27979576/9881278
execute "set spellfile=".g:dotfiles_dir."/vim/spell/pt.utf-8.add"

"## Fun√ß√µes
"### NN_
" Fun√ß√µes que s√£o usadas com frequencia n√£o t√£o alta para serem comandos ou
" maps, padr√£o NN_ para ficar f√°cil achar com :call NN_<tab>
" Fun√ß√µes muito usadas por√©m n√£o tanto a ponto de virarem comandos ou maps
" O padr√£o NN_ serve para ficar f√°cil achar com :call NN_<tab>

" Att ctags
" Necessario instalar ctags ou universal ctags
function! NN_ctags()
    let s:ctags_command="ctags" . 
                \ " -R --totals" .
                \ " --exclude=.git --exclude=.svn" .
                \ " --exclude=vendor" .
                \ " --exclude=node_modules --exclude=dist --exclude=build --exclude=ios --exclude=android" .
                \ " --exclude=_site" .
                \ " --languages=php,javascript"

    " procura se existe um arquivo .ctags a mais
    if filereadable(expand(".ctags"))
        let s:ctags_command.=" --options=.ctags"
    endif

    " seta pasta atual como alvo do ctags
    let s:ctags_command.=" ."

    " executa o comando montado na string
    execute "!".s:ctags_command
endfun


" Habilita e desabilita emojis, ideal para perf
function! NN_EmojiToggle()
    if &renderoptions == ""
        set renderoptions=type:directx,gamma:1.0,contrast:0.1,level:1.0,geom:1,renmode:5,taamode:1
    else
        set renderoptions=
    endif
endfun

" Atualiza diret√≥rio atual (:pwd) com dir do projeto, com raiz .git
" THANKS: https://michaelheap.com/set-parent-git-directory-to-current-path-in-vim/
function! NN_SetGitDir()
    " Change working dir to the current file
    cd %:p:h
    " Set 'gitdir' to be the folder containing .git
    let gitdir=system("git rev-parse --show-toplevel")
    " See if the command output starts with 'fatal' (if it does, not in a git repo)
    let isnotgitdir=matchstr(gitdir, '^fatal:.*')
    " If it empty, there was no error. Let's cd
    if empty(isnotgitdir)
        cd `=gitdir`
    endif
endfunction

" Abre :Lexplorer com pwd como do git
" THANKS: https://michaelheap.com/set-parent-git-directory-to-current-path-in-vim/
function! NN_Lexplorer()
    call NN_SetGitDir()
    Lexplore
endfunction

" Lista TODOS e FIXMES
" THANKS: https://www.commandlinefu.com/commands/view/12833/get-a-list-of-all-todofixme-tasks-left-to-be-done-in-your-project
" OBS: Ir√° ignorar path do wildignore https://stackoverflow.com/a/20042050
" FIXME ativa :GitGutterToggle
function! NN_Tasks()
    call NN_SetGitDir()
    "silent !git grep -EIn "TODO|FIXME"
    lvimgrep /\C\<TODO\>\|\C\<FIXME\>/j **
    lopen
endfunction

" Commita projetos de aulas com o padr√£o :tv: add aula <numero>
function! NN_GitAula()
    let log = system("git log --pretty=format:\%s")
    vnew
    put=log
    normal! gg
    if search('^:tv: add aula')>0
        normal! 3W
        let s:numero_aula = expand('<cword>')+1
        echom system("git add -A && git commit -m \":tv: add aula ".s:numero_aula."\"")
    else
        echom system("git add -A && git commit -m \":tv: add aula 1\"")
    endif
    bdelete!
endfunction

function! NN_Git_add()
    echo "n√£o implementado!"
endfunction

"### vimrc
" Fun√ß√µes que s√£o mapeadas ou usadas como comando por arquivo

" Pesquisa palavra em todo o projeto
" https://stackoverflow.com/questions/20933836/what-is-the-difference-between-location-list-and-quickfix-list-in-vim
" THANKS: https://github.com/jmharvey/vim/blob/master/vimrc#L207
" THANKS: https://vimrcfu.com/snippet/104
" FIXME Ativa gitguttertoggle
function! s:Grep(grepword)
    call NN_SetGitDir()
    if len(a:grepword) == 0
        let s:grepword = input("Grep: ")        
    else
        let s:grepword = a:grepword
    endif
    "exec "silent !git grep -EIn \"" . grepword . "\""
    " exec "vimgrep /".s:kwd."/ %"|" No arquivo
    exec "lvimgrep /\\<" . s:grepword . "\\>/j **"
    lopen
endfunction

" Fecha split ou deleta o buffer
function! s:FechaSplitOuDeletaBuffer()
    if winnr('$') > 1
        q
    else
        bd
    endif
endfunction

" Fecha split ou deleta o buffer ignorando modifica√ß√µes
function! s:FechaSplitOuDeletaBufferForced()
    if winnr('$') > 1
        q!
    else
        bd!
    endif
endfunction

"### Shared script
" Fun√ß√µes privadas que s√£o usadas entre multiplos arquivos,
" portanto n√£o devem ser marcadas com s:

" Carrega arquivo se ele existe
" THANKS: https://devel.tech/snippets/n/vIIMz8vZ/load-vim-source-files-only-if-they-exist/
function! SourceIfExists(file)
    if filereadable(expand(a:file))
        exe 'source' a:file
    endif
endfunction

"## Comandos
" Recarrega vimrc com trigger para o filetype
" THANKS: https://vi.stackexchange.com/questions/9338/why-cannot-i-source-vimrc-for-the-current-file-being-editing
command! Sov source $MYVIMRC | e %

" Fecha (sem for√ßar) todos buffers e deixar somente um
" THANKS: https://salferrarello.com/vim-close-all-buffers-except-the-current-one/
command! BufOnly execute 'kb|%bdelete|e #|b#|bd%|normal `b'

" Abre terminal em split, ideal para o gvim
" FIXME n√£o funciona corretamente no linux
" THANKS: https://stackoverflow.com/a/38082196
command! TerminalGitRootVertical exec 'call NN_SetGitDir() | vert term ++kill=term'
command! TerminalGitRootHorizontal exec 'call NN_SetGitDir() | term ++kill=term'

" Procura palavra no projeto
" :Grep<CR>
" Grep: <palavra>
command! Grep :call <SID>Grep("")<cr>

" Visualiza todos highlight-groups
"   :so $VIMRUNTIME/syntax/hitest.vim
" Visualiza highlight group da palavra sob o cursor
" THANKS: https://vim.fandom.com/wiki/Identify_the_syntax_highlighting_group_used_at_the_cursor
" :highlight mostra as cores do grupo
command! Syntax echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<' . synIDattr(synID(line("."),col("."),0),"name") . "> lo<" . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"

" Exibe splits para trabalhar como kanban
command! TodoList exec ":cd ".g:todolist_dir | e DONE | belowright vnew TODO | aboveleft vnew DOING

"## Mapeamentos
":map -> lista todos mapeamentos para o arquivo

" TODO ver funcionamento do localleader (:h maplocalleader)
let mapleader="\<space>"

nnoremap    <leader><leader>    :w<CR>
nnoremap    <leader><cr>        :call NN_Lexplorer()<cr>
nnoremap    <leader>/           :noh<cr>
nnoremap    <leader>.           :pwd<CR>
nnoremap    <leader>dd          :call <SID>FechaSplitOuDeletaBuffer()<CR>
nnoremap    <leader>df          :call <SID>FechaSplitOuDeletaBufferForced()<CR>
nnoremap    <leader>ds          :on<CR>| " Close all splits
nnoremap    <leader>n           :call NN_<tab><left>| " fun√ß√µes pessoais
nnoremap    <leader>s           :split<CR>
nnoremap    <leader>t           :tn <c-r><c-w><CR>| " Goto definition (ctags)
nnoremap    <leader>v           :vsplit<CR>
nnoremap    <leader>y           my^vg_"+y:echo "Copiado!!"<CR>
vnoremap    <leader>y           "+y:echo "Copiado!!"<CR>

nnoremap    #           :b #<CR>|" FIXME volta para unlisted buffer tbm
nnoremap    !!          :!!<CR>
vnoremap    <           <gv|" mant√™m select ap√≥s indenta√ß√£o
vnoremap    >           >gv|" mant√™m select ap√≥s indenta√ß√£o
inoremap    "           ""<left>|"autoclose
inoremap    '           ''<left>|"autoclose
inoremap    {           {}<left>|"autoclose
inoremap    {}          {}|"evitar {}}
inoremap    {<CR>       {}<left><CR><Esc>O|"autoclose
inoremap    {<space>    {}<left><space><space><left>|"autoclose
inoremap    (           ()<left>|"autoclose
inoremap    ()          ()|"evitar ())
inoremap    (<CR>       ()<left><CR><Esc>O|"autoclose
inoremap    (<space>    ()<left><space><space><left>|"autoclose
inoremap    [           []<left>|"autoclose
inoremap    []          []|"evitar []]
inoremap    [<CR>       []<left><CR><Esc>O|"autoclose
inoremap    [<space>    []<left><space><space><left>|"autoclose
vnoremap    J           :m '>+1<CR>gv=gv| " move sele√ß√£o pra baixo
vnoremap    K           :m '<-2<CR>gv=gv| " move sele√ß√£o pra cima
inoremap    kj          <esc>|" esc mais f√°cil
nnoremap    n           nzzzv|" centraliza match do search
nnoremap    N           Nzzzv|" centraliza match do search
vnoremap    o'          c'<c-r>"'|" surround match
vnoremap    o"          c"<c-r>""|" surround match
vnoremap    o(          c(<c-r>")|" surround match
vnoremap    o{          c{<c-r>"}|" surround match
vnoremap    o[          c[<c-r>"]|" surround match
nnoremap    Q           @q|" executa macro em 'q' (letra que mais gravo)
tnoremap    <esc>       <C-\><C-n>
noremap     \           za|" toggle fold
nnoremap    <expr><f2>  &foldlevel ? 'zM' :'zR'| " Toggle fold todo arquivo
noremap     <up>        <nop>|" for√ßa hjkl
noremap     <down>      <nop>|" for√ßa hjkl
noremap     <left>      <nop>|" for√ßa hjkl
noremap     <right>     <nop>|" for√ßa hjkl
inoremap    <up>        <nop>|" for√ßa hjkl
inoremap    <down>      <nop>|" for√ßa hjkl
inoremap    <left>      <nop>|" for√ßa hjkl
inoremap    <right>     <nop>|" for√ßa hjkl
nnoremap    <c-\>       <c-]>|" teclado brasileiro <c-]> n√£o funciona
inoremap    <c-a>       <C-O>yiW<End>=<C-R>=<C-R>0<CR>| " tip 73 (vim.fandom)
inoremap    <c-h>       <left>|" for√ßa hjkl
" nnoremap    <c-h>       <c-w>h
cnoremap    <c-h>       <left>
inoremap    <c-j>       <down>|" for√ßa hjkl
" nnoremap    <c-j>       <c-w>j
nnoremap    <c-j>       <c-w>w|" estilo DWM
inoremap    <c-k>       <up>|" for√ßa hjkl
" nnoremap    <c-k>       <c-w>k
nnoremap    <c-k>       <c-w>W|" estilo DWM
" nnoremap    <c-l>       <c-w>l
cnoremap    <c-l>       <right>
inoremap    <c-l>       <right>|" for√ßa hjkl
tnoremap    <c-l>       cls<cr>
nnoremap    <c-n>       yiwV| " substitue mult cursors
xnoremap    <c-n>       :s/<c-r><c-*>//g<left><left>| " substitue mult cursors
inoremap    <c-q>       <esc>:call JumpToTag()<cr>| " <++>
nnoremap    <c-q>       :call JumpToTag()<cr>| " <++>
nnoremap    <c-s>       mi<esc>gg=G`i|" indenta todo o arquivo
nnoremap    <c-z>       u|" remove comportamento <c-z>
tnoremap    <s-insert>  <c-w>"*
tnoremap    <c-s-v>     <c-w>"*

"## Abrevia√ß√µes
cnoreabbrev W! w!
cnoreabbrev Q! q!
cnoreabbrev Qa! qa!
cnoreabbrev QA! qa!
cnoreabbrev Wq wq
cnoreabbrev Wa wa
cnoreabbrev wQ wq
cnoreabbrev WQ wq
cnoreabbrev W w
cnoreabbrev Q q
cnoreabbrev Qa qa
cnoreabbrev QA qa
cnoreabbrev Wqa wqa
cnoreabbrev WQa wqa
cnoreabbrev WQA wqa
cnoreabbrev wQA wqa
cnoreabbrev wqA wqa
cnoreabbrev wQa wqa

" Simplifica√ß√£o do lvim:
" Lista resultados da palavra sob o cursor
" THANKS: https://vim.fandom.com/wiki/Find_in_files_within_Vim
cabbrev lvim
            \ noautocmd lvim /\<lt><C-R><C-W>\>/gj
            \ **<C-R>=(expand("%:e")=="" ? "" : ".".expand("%:e"))<CR>
            \ <Bar> lw
            \ <C-Left><C-Left><C-Left>

"## AutoCmds
" THANKS: https://vi.stackexchange.com/questions/9455/why-should-i-use-augroup
"augroup tempos
"    autocmd InsertEnter * set timeoutlen=700
"    autocmd InsertLeave * set timeoutlen=1000
"augroup END

"### ftdetect
" THANKS: https://www.reddit.com/r/vim/wiki/where_to_put_filetype_specific_stuff
" FIXME Como colocar defini√ß√£o de filetype em ftdetect?
augroup filetype_detect
    au!
    au BufRead,BufNewFile *.phtml setfiletype html
    au BufRead,BufNewFile *.hbs setfiletype html
    au BufRead,BufNewFile *.gv setfiletype dot
    au BufRead,BufNewFile TODO setfiletype todolist
    au BufRead,BufNewFile DOING setfiletype todolist
    au BufRead,BufNewFile DONE setfiletype todolist
augroup END

"## packs pessoais
" Funcionalidades que podem virar mini packages/plugins.
" Alguns podem estar em packages.vim

"### Diagrama ascii
" Desenho de diagramas, √∫til para apresenta√ß√µes em markdown
" +-----+     +-----+
" |texto|     |texto|
" +--+--+     +-----+
"    |           ^
"    |           |
"    |        +--+--+ 
"    +------->|texto|
"             +-----+

" Desenha caixa de texto para diagramas ascii
" THANKS: https://github.com/vim-scripts/DrawIt/blob/master/autoload/DrawIt.vim#L2494
fun! Boxdraw()
    set virtualedit=all

    " Cancela virtual edit
    "set virtualedit=

    let row0   = line("'<") - 1
    let col0   = virtcol("'<") - 1
    let row1   = line("'>") + 1
    let col1   = virtcol("'>") + 1

    let quantidadeL = col1 - col0
    call cursor(row1, col0)
    exec "normal! v".quantidadeL."lr-"
    call cursor(row0, col0)
    exec "normal! v".quantidadeL."lr-"

    let quantidadeJ = row1 - row0
    call cursor(row0, col0)
    exec "normal! \<c-v>".quantidadeJ."jr|"
    call cursor(row0, col1)
    exec "normal! \<c-v>".quantidadeJ."jr|"

    call cursor(row0, col0)
    normal! r+
    call cursor(row1, col0)
    normal! r+
    call cursor(row0, col1)
    normal! r+
    call cursor(row1, col1)
    normal! r+
endfunction

" Desenha conectores entre caixas
function! Connectordraw()
    " coordenadas que iniciaram ou terminaram a sele√ß√£o
    let row0 = line("'<")
    let col0 = virtcol("'<")
    let row1 = line("'>")
    let col1 = virtcol("'>")

    let rowI = 0
    let colI = 0

    call cursor(row0, col0)
    let conteudoPosicaoInicial = getline('.')[col('.')-1]
    if(conteudoPosicaoInicial == '-' || conteudoPosicaoInicial == '|')
        let rowI = line('.')
        let colI = virtcol('.')
    endif
    call cursor(row1, col1)
    let conteudoPosicaoInicial = getline('.')[col('.')-1]
    if(conteudoPosicaoInicial == '-' || conteudoPosicaoInicial == '|')
        let rowI = line('.')
        let colI = virtcol('.')
    endif

    " cancela seta
    if(rowI == 0)
        return
    endif

    " TESTES: https://codepen.io/nenitf/pen/xxVwYmL?editors=0010

    let rowF = rowI == row0 ? row1 : row0
    let colF = colI == col0 ? col1 : col0

    let rowM = col0 == col1 ? rowI : rowF
    let colM = row0 == row1 ? colI : colF

    let primeiraReta = 0
    let segundaReta = 0

    call cursor(rowI, colI)
    let conteudoPosicaoInicial = getline('.')[col('.')-1]
    if(conteudoPosicaoInicial == '-')
        let primeiraReta = '|'
        let segundaReta = '-'
        let colM = colI
    else
        let primeiraReta = '-'
        let segundaReta = '|'
        let rowM = rowI
    endif

    if(rowI > rowM)
        let quantidadeJ = rowI - rowM
        call cursor(rowM, colM)
        exec "normal! \<c-v>".quantidadeJ."jr|"
    elseif(rowI < rowM)
        let quantidadeJ = rowM - rowI
        call cursor(rowI, colI)
        exec "normal! \<c-v>".quantidadeJ."jr|"
    elseif(colI > colM)
        call cursor(rowM, colM)
        let quantidadeL = colI - colM
        exec "normal! v".quantidadeL."lr-"
    elseif(colI < colM)
        call cursor(rowI, colI)
        let quantidadeL = colM - colI
        exec "normal! v".quantidadeL."lr-"
    endif

    if(rowM > rowF)
        let arrowHead = '^'
        let quantidadeJ = rowM - rowF
        call cursor(rowF, colF)
        exec "normal! \<c-v>".quantidadeJ."jr|"
    elseif(rowM < rowF)
        let arrowHead = 'v'
        let quantidadeJ = rowF - rowM
        call cursor(rowM, colM)
        exec "normal! \<c-v>".quantidadeJ."jr|"
    elseif(colM > colF)
        let arrowHead = '<'
        let quantidadeL = colM - colF
        call cursor(rowF, colF)
        exec "normal! v".quantidadeL."lr-"
    elseif(colM < colF)
        let arrowHead = '>'
        let quantidadeL = colF - colM
        call cursor(rowM, colM)
        exec "normal! v".quantidadeL."lr-"
    endif

    call cursor(rowI, colI)
    normal! r+
    call cursor(rowM, colM)
    normal! r+
    call cursor(rowF, colF)
    exec "normal! r".arrowHead
endfunction

vnoremap + :<c-u>call Boxdraw()<CR>
vnoremap - :<c-u>call Connectordraw()<CR>

"### Fake vimwiki
" Replica das fun√ß√µes que uso do plugin vimwiki, maps e demais configura√ß√µes
" espec√≠ficas de markdown em seu respectivo arquivo
"
" OBJETIVOS:
"   - Acessar rapidamente uma ou mais wikis
"   - Acessar [arquivo](arquivo) markdorn com enter, agilizando navega√ß√£o
"   - Marcar e desmarcar checkbox com <c-space> - [ ] - [x]

function! s:SelecionaWiki(wiki)
    let wiki = g:vimwikis_dirs[0]

    if(a:wiki == 1)
        " THANKS: https://learnvimscriptthehardway.stevelosh.com/chapters/39.html
        let wikis_com_index = deepcopy(g:vimwikis_dirs)
        call map(wikis_com_index,'v:key . ". " . v:val')
        let index_secionado = inputlist(wikis_com_index)
        let wiki = g:vimwikis_dirs[index_secionado]
    endif
    try
        execute "cd " . wiki
        e README.md
    catch
        return
    endtry
endfunction

nnoremap <leader>ww :call <SID>SelecionaWiki(0)<CR>
nnoremap <leader>ws :call <SID>SelecionaWiki(1)<CR>

"### OutputAssertion
" 'Frameworkk' de testes com a pegada do udebug
" https://www.udebug.com/UVa/100
" Onde √© feito um diff do output de um script e
" o arquivo 'outputassertion.txt'

" Sugest√µes do :OutputAssertion <tab>
function! ListExecutaveis(A,L,P)
    return "python3\nnode\ngo run\nlua"
endfunction

" TODO desacoplar execu√ß√£o com cria√ß√£o da tab
function! OutputAssertion(command)
    execute "tabnew | 0r!".a:command." #"

    " faz o vim entender que n√£o queremo salvar esse arquivo
    setlocal buftype=nofile
    normal! Gdd
    nnoremap <buffer> q :windo bd!<CR>
    new

    " deixar em cima a mensagem
    " caso tenha: set splitbelow
    " √© o ideal
    " wincmd r
    normal! iUse "q" para fechar todos os buffers

    " faz o vim entender que n√£o queremo salvar esse arquivo
    setlocal buftype=nofile
    wincmd w

    " resize o m√°ximo
    wincmd _

    vert diffsplit outputassertion.txt
    nnoremap <buffer> q :windo bd!<CR>
    wincmd l
endfunction

" :OutputAssertion python
command -complete=custom,ListExecutaveis -nargs=+ OutputAssertion :execute ":call OutputAssertion(\"<args>\")"

"### Highlight Word
" Colore palavras (como se fosse o search)
" Antes do pack: 
" nnoremap    <kMultiply> *N| "https://stackoverflow.com/a/24537701
" THANKS: https://bitbucket.org/sjl/dotfiles/raw/d8f861e3276a89c0f98637725006da658adcda90/vim/vimrc

function! HiInterestingWord(n)
    " Defini√ß√£o do highlight, por algum motivo pelo vimrc n√£o ocorre
    hi def InterestingWord1 guifg=#000000 ctermfg=16 guibg=#ffa724 ctermbg=214
    hi def InterestingWord2 guifg=#000000 ctermfg=16 guibg=#aeee00 ctermbg=154
    hi def InterestingWord3 guifg=#000000 ctermfg=16 guibg=#8cffba ctermbg=121
    hi def InterestingWord4 guifg=#000000 ctermfg=16 guibg=#b88853 ctermbg=137
    hi def InterestingWord5 guifg=#000000 ctermfg=16 guibg=#ff9eb8 ctermbg=211
    hi def InterestingWord6 guifg=#000000 ctermfg=16 guibg=#ff2c4b ctermbg=195

    " Save our location.
    normal! mz

    " Yank the current word into the z register.
    normal! "zyiw

    " Calculate an arbitrary match ID.  Hopefully nothing else is using it.
    let mid = 86750 + a:n

    " Clear existing matches, but don't worry if they don't exist.
    silent! call matchdelete(mid)

    " Construct a literal pattern that has to match at boundaries.
    let pat = '\V\<' . escape(@z, '\') . '\>'

    " Actually match the words.
    call matchadd("InterestingWord" . a:n, pat, 1, mid)

    " Move back to our original location.
    normal! `z
endfunction

" TODO remover/resetar um ou todos highlights
nnoremap <leader>1 :call HiInterestingWord(1)<cr>
nnoremap <leader>2 :call HiInterestingWord(2)<cr>
nnoremap <leader>3 :call HiInterestingWord(3)<cr>
nnoremap <leader>4 :call HiInterestingWord(4)<cr>
nnoremap <leader>5 :call HiInterestingWord(5)<cr>
nnoremap <leader>6 :call HiInterestingWord(6)<cr>

"### Coment√°rio
" THANKS: https://stackoverflow.com/a/24046914
let s:comment_map = { 
            \   "c": '\/\/',
            \   "cpp": '\/\/',
            \   "dot": '\/\/',
            \   "go": '\/\/',
            \   "java": '\/\/',
            \   "javascript": '\/\/',
            \   "javascriptreact": '\/\/',
            \   "typescript": '\/\/',
            \   "typescriptreact": '\/\/',
            \   "lua": '--',
            \   "scala": '\/\/',
            \   "php": '\/\/',
            \   "python": '#',
            \   "ruby": '#',
            \   "rust": '\/\/',
            \   "sh": '#',
            \   "bashrc": '#',
            \   "vim": '"',
            \ }

function! ToggleComment()
    if has_key(s:comment_map, &filetype)
        let comment_leader = s:comment_map[&filetype]
        if getline('.') =~ "^\\s*" . comment_leader . " " 
            " Uncomment the line
            execute "silent s/^\\(\\s*\\)" . comment_leader . " /\\1/"
        else 
            if getline('.') =~ "^\\s*" . comment_leader
                " Uncomment the line
                execute "silent s/^\\(\\s*\\)" . comment_leader . "/\\1/"
            else
                " Comment the line
                execute "silent s/^\\(\\s*\\)/\\1" . comment_leader . " /"
                " execute "silent s/^/\\1" . comment_leader . " /"
            end
        end
    end
endfunction

nnoremap gc :call ToggleComment()<cr>
vnoremap gc :call ToggleComment()<cr>

"### Snippets
" Snippets feitos com macros

" modelo de snippet
" DEMO: snip<space> 
inoreabbrev <expr> snip TestaTriggerSnippet('snip',
            \ "snip(let i=0;x > 10;x++){<cr>/* codigo */<cr>}",
            \ ['let i=0', 'x > 10', 'x++', '\/\* codigo \*\/'])

function! TestaTriggerSnippet(abbr, expansion, placeholders)
    let g:placeholders = a:placeholders
    let s:expansion = a:expansion.
                \ "\<Esc>:call PlaceHolder('?')\<CR>"
            " \ "\<Esc>g_"
            " \ "\<C-R>=Eatchar('\s')\<CR>"
    let c = nr2char(getchar(0))
    if c == g:nonkw_snippet_trigger
        return s:expansion
    else
        return a:abbr . c
    endif
endfunction

inoremap <c-j> <ESC>:call PlaceHolder('/')<CR>
snoremap <c-j> <ESC>:call PlaceHolder('/')<CR>
snoremap <bs>  i<bs>

" Marca pr√≥xima substitui√ß√£o
" TODO tornar stateless
let g:placeholders = []
function! PlaceHolder(backward)
    if get(g:placeholders, 0, '0') != '0'
        if search(g:placeholders[0], 'nw')>0
            let placeholder = g:placeholders[0]
            unlet g:placeholders[0]

            if get(g:placeholders, 0, '0') != '0'
                highlight link NeniSnippetPlaceHolder DiffAdd
                execute 'match NeniSnippetPlaceHolder /'.g:placeholders[0].'/'
            else
                execute "match NeniSnippetPlaceHolder //"
            endif

            execute "normal! ".a:backward.placeholder."\<cr>"
            execute "normal! gn\<c-g>"
        else
            execute "normal! a".g:placeholders
        endif
    endif
endfunction

" snippet + \
let g:nonkw_snippet_trigger = "\<space>"

" 'Desabilita' trigger snippet
" Ao inv√©s de desabilitar, se for usado <c-v> no insert-mode o pr√≥ximo char
" n√£o ativa a abrevia√ß√£o
command! AbbrevToggle if g:nonkw_snippet_trigger=="\\"
            \|let g:nonkw_snippet_trigger="\<space>"
            \|else|let g:nonkw_snippet_trigger="\\"|endif

"#### Listas
" THANKS: :h complete()
function! AutoCompleteCarinhas()
    call complete(col('.'), [
                \ '‡≤•_‡≤•',
                \ '·Éö(‡≤†Áõä‡≤†·Éö)',
                \ '‡≤†‚ï≠‚ïÆ‡≤†',
                \ '(‚ïØ¬∞‚ñ°¬∞)‚ïØÔ∏µ  ûooq«ù…î…ê…ü',
                \ '(‚ïØ¬∞‚ñ°¬∞)‚ïØÔ∏µ ‚îª‚îÅ‚îª',
                \ '(‚ïÆ¬∞-¬∞)‚ïÆ‚î≥‚îÅ‚î≥',
                \ '( Õ°¬∞ Õú ñ Õ°¬∞)',
                \ '¬Ø\_(„ÉÑ)_/¬Ø',
                \ '(~Àò‚ñæÀò)~',
                \ '·ï¶(√≤_√≥Àá)·ï§',
                \])
    return ''
endfunction
inoremap <c-z> <c-r>=AutoCompleteCarinhas()<CR>

"## Sources
":scriptnames para ver a orderm e quais scripts foram iniciados

call SourceIfExists(g:dotfiles_dir."/vim/dotfiles.vim")
call SourceIfExists(g:dotfiles_dir."/vim/packages.vim")

"### local
call SourceIfExists("~/.vimrc-local.vim")

"#### Sugest√µes para o vimrc-local
" Configura√ß√µes que afetam a perf, mistura vim builtin e plugins, exemplo:
"
" call SourceIfExists(g:dotfiles_dir."/vim/plus.vim")
"
" let g:startify_lists = [
"             \ { 'type': 'sessions', 'header': ['sess√µes'] },
"             \ { 'type': 'commands', 'header': ['comandos'] },
"             \ ]
" 
" let g:startify_commands = [
"             \ {'g': ['gostack11', 'e ~/dev/gostack11']},
"             \ ]
"
"set rtp+=~/.fzf

"### pwd
" Carregamento de 'vimrc' existente no work dir (:h :pwd :h 'getcwd()')
" ideal para setar wildignore para remover pesquisa de paths de libs
" TODO remover source quando outro .exrc for carregado
au DirChanged * :call SourceIfExists(fnamemodify('.exrc', ":p"))

" OBS:
" exrc n√£o resolve o problema pois ele s√≥ carrega o .vimrc .exrc _vimrc ou
" _exrc no momento que o vim √© aberto no diret√≥rio, ou seja, o startify n√£o da
" o gatilho, mas √© uma op√ß√£o interessante caso seja usado somente no terminal
"set exrc
"set secure
" THANKS: https://superuser.com/a/532673
