" vim: set fo+=t:
"
" Arquivo de configurações básicas do vim, podendo ser adicionado
" de maneira independente do repo dotfiles. Basta copiar o conteúdo para
" o arquivo %userprofile%\_vimrc no Windows ou em $HOME/.vimrc no Linux.
" - https://raw.githubusercontent.com/nenitf/dotfiles/master/vim/base.vim
"
" Livros abertos sobre vim:
" - https://vimbook.gitbook.io/vimbook/
" - https://sedilson.github.io/vimparanoobs/index.html
"
" Este arquivo utiliza os folds do vim, abaixo um resumo de como usar (:h folds):
" - https://vim.fandom.com/wiki/Folding
" - https://pt.wikibooks.org/wiki/Vim/Usando_folders
" - https://www.linux.com/tutorials/vim-tips-folding-fun/
"
" zj zk pulo de fold
" [z ]z gg G de um fold aberto
"
"|             | primeiro nivel |  recursivo  |
"|-------------|----------------|-------------|
"|todo arquivo |     zr/zm      |  zR/zM (F2) |
"|             |   reduce/more  | reduce/more |
"|-------------|----------------|-------------|
"|sob o cursor |   zo/zc ou za  | zO/zC ou zA |
"
" dotfiles interessantes:
" - https://github.com/tpope/tpope
" - https://github.com/woliveiras/dotfiles/blob/master/bin/system-settings/.vimrc
"
" DICAS:
"   - Usar K (:h K) em cima da palavra da configuração para consultar manual
"   - propriedades que são setadas podem voltar ao seu valor inicial com &,
"   por exemplo set wildmenu&
"
"## Buffers
" Motivos para usar buffer ao invés de tabs:
"   - O mesmo arquivo não é aberto duas vezes
"   - Mais velocidade pois a janela não precisa ser redesenhada

set hidden " mantêm o arquivo disponível ao sair dele (mesmo modificado)
" :ls lista os buffers
"## Aparência e som
syntax on                   " syntax de acordo com o filetype
filetype plugin indent on   " carrega ftplugin.vim e indent.vim do runtimepath (plugins)
set background=dark         " ajusta cores para um fundo escuro
colorscheme slate           " tema de cores slate (junto com vim) para syntax
set number relativenumber   " exibe régua com o numero relativo das linhas
set showmatch               " mostra fechamento de {[()]}
set autoindent              " auto indentação
set mouse=a                 " libera uso do mouse em todos modos
set linebreak               " quebra a linha por palavra e não por letra
set cursorcolumn cursorline " marca colunha e linha do cursor
set showcmd                 " mostra os comandos no canto inferior direito

" Limite de coluna, comentado para ser posto em modelines específicas
" set textwidth=80            " define largura da linha de texto
" set formatoptions+=t        " quebra a linha na coluna textwidth (Vgq)
set colorcolumn=81          " marca coluna 81

" Remove som ao apertar multiplos ESCs
" https://vim.fandom.com/wiki/Disable_beeping"
set noerrorbells visualbell t_vb=
autocmd GUIEnter * set visualbell t_vb=
set belloff+=ctrlg                      " if Vim beeps during completion
"Obs: para o gvim editar o _gvimrc (windows) ou .gvimrc (linux)
"## Modeline
set modeline        " habilita uso da modeline
set modelines=5     " procura as 5 primeiras ou ultimas linhas do arquivo
" Exemplo de modeline:
" vim: set fdm=marker:
"## Statusline
set laststatus=2                " habilita statusline
set statusline=                 " reseta statusline
set statusline+=\ %r\%m\%f\     " nome readonly, modificado e nome abreviado
set statusline+=\%=				" espaço
set statusline+=\ %p%%\ %l:\%c  " rownumber, total e percentual
"## Popup de sugestão
set wildmenu                            " habilita menu
set completeopt=menuone                 " mostra menu de opções
set shortmess+=c                        " remove mensagens inúteis do wildmenu
set omnifunc=syntaxcomplete#Complete    " c-x c-o pelo filetype do buffer aberto
set complete=.,k,w,b                    " add sugestão do wildmenu, tags pesam muito
"## Conteúdo do buffer aberto
set encoding=utf-8
"set fileencoding=utf-8 "?
"set fileencodings=utf-8 "?
set fileformats=unix,dos,mac
"set bomb "?
"set binary "?
set nrformats-=octal            " ctrl-a ctrl -x

set nobackup    " para não criar arquivo de bkp
set noswapfile  " para não criar arquivo swap

" Checar quando o texto for modificado
set autoread
au FocusGained,BufEnter * :silent!<space>!

" Permite usar <bs> mesmo indo contra auto-intent, eol e inicio da linha
" https://vi.stackexchange.com/questions/2162/why-doesnt-the-backspace-key-work-in-insert-mode
set backspace=indent,eol,start
"### Tabs/espaços
" https://stackoverflow.com/questions/1878974/redefine-tab-as-4-spaces
set tabstop=4
set softtabstop=4
set shiftwidth=4
set smarttab
set expandtab
"## Pesquisa no buffer aberto
set hlsearch    " colore os matches
set incsearch   " vai colorindo a pesquisa durante a digitação
set ignorecase  " ignora case sensitive na busca
"## Fold
function! FoldTextHashtag()
    let nl = v:foldend - v:foldstart + 1
    let titulo = substitute(getline(v:foldstart),"^\""," ",'g')
    let titulo = substitute(titulo,"\ ","",'')
    let titulo = substitute(titulo,"\#","\ ",'g')
    "let txt = '+ (' . nl . ')' . titulo . ' '
    let txt = '+' . titulo . ' (' . nl . ') '
    return txt
endfunction
"### Markdown
function! FoldMarkdown()
    if getline(v:lnum) =~ '^## .*$'
        return ">1"
    endif
    if getline(v:lnum) =~ '^### .*$'
        return ">2"
    endif
    if getline(v:lnum) =~ '^#### .*$'
        return ">3"
    endif
    if getline(v:lnum) =~ '^##### .*$'
        return ">4"
    endif
    if getline(v:lnum) =~ '^###### .*$'
        return ">5"
    endif
    return "=" 
endfunction

au FileType markdown set foldexpr=FoldMarkdown()  
au FileType markdown set foldmethod=expr
au FileType markdown set foldtext=FoldTextHashtag()
"":lvimgrep /^"#/ % | lw
"### VimScript
function! FoldVimScript()
    if getline(v:lnum) =~ '^"## .*$'
        return ">1"
    endif
    if getline(v:lnum) =~ '^"### .*$'
        return ">2"
    endif
    if getline(v:lnum) =~ '^"#### .*$'
        return ">3"
    endif
    if getline(v:lnum) =~ '^"##### .*$'
        return ">4"
    endif
    if getline(v:lnum) =~ '^"###### .*$'
        return ">5"
    endif
    return "=" 
endfunction
" https://stackoverflow.com/questions/5983396/change-the-text-in-folds
" https://jdhao.github.io/2019/08/16/nvim_config_folding/

au FileType vim set foldexpr=FoldVimScript()
au FileType vim set foldmethod=expr
au FileType vim set foldtext=FoldTextHashtag()
"## Netrw
" Como não criar NetrwTreeListing e .netrwhist?
" - :edit a folder to open a file browser
" - <CR>/v/t to open in an h-split/v-split/tab
" - check |netrw-browse-maps| for more mappings
"let g:netrw_banner=0        " disable annoying banner
"let g:netrw_browse_split=4  " open in prior window
let g:netrw_liststyle=3     " tree view

"https://stackoverflow.com/a/8731175
let g:netrw_bufsettings = 'noma nomod nu nobl nowrap ro'
"## Declaração de funções (macros)
" Créditos: https://stackoverflow.com/questions/6496778/vim-run-autocmd-on-all-filetypes-except
fun! Dos2unix()
    " Don't strip on these filetypes
    " :echo &ft
    if &ft =~ 'startify\|nerdtree'
        return
    endif
    :e ++ff=dos
endfun

" Função utilizada para limpar a tela do terminal
" Dependendo do SO muda o comando...
fun LimpaTerminal()
    if has("win32")
        silent !cls
    else
        silent !clear
    endif
endfun
"## Mapeamentos/Comandos e abreviações (macros)
":map -> lista todos mapeamentos para o arquivo

let mapleader="\<space>"

" Identa todo arquivo e volta ao ponto de partida
nnoremap <C-S> mi<esc>gg=G`i

" Mostra o diretório corrente, raiz para acessar arquivos com :e
noremap <leader>. :pwd<CR>

" Mais ergonômico
inoremap <c-f> <c-o>
inoremap kj <esc>
autocmd InsertEnter * set timeoutlen=200
autocmd InsertLeave * set timeoutlen=1000
"### Salvar/sair rapidamente
noremap <leader><leader> :w<CR>
cnoreabbrev W! w!
cnoreabbrev Q! q!
cnoreabbrev Qa! qa!
cnoreabbrev QA! qa!
cnoreabbrev Wq wq
cnoreabbrev Wa wa
cnoreabbrev wQ wq
cnoreabbrev WQ wq
cnoreabbrev W w
cnoreabbrev Q q
cnoreabbrev Qa qa
cnoreabbrev QA qa
"### Undo/redo
nnoremap <c-z> u
" re do with <C-R> built-in
"### Fold
nnoremap <silent> <tab> za
" reduz/mostra conteudo dos folds
nnoremap <expr> <f2> &foldlevel ? 'zM' :'zR'
"### Buffers
" View and select buffers
" CtrlP possui a mesma feature
"nnoremap <Tab> :ls <CR>:b<space>

" Fechar (sem forçar) todos buffers e deixar somente um
" Créditos: https://salferrarello.com/vim-close-all-buffers-except-the-current-one/
command! BufOnly execute 'kb|%bdelete|e #|b#|bd%|normal `b'

" Créditos: https://stackoverflow.com/a/38082196
command! TerminalGitRoot exec 'cd' fnameescape(fnamemodify(finddir('.git',
            \ escape(expand('%:p:h'), ' ') . ';'), ':h'))
            \ '|term'

" Open new file in buffer
" Atualmente é mais eficar usar ctrlp, mas o truque é top
" nnoremap <c-n> :e **/*

" Deleção de buffers
nnoremap <silent> <leader>dd :bd<CR>
nnoremap <silent> <leader>df :bd!<CR>

" Troca de buffers
"nnoremap <Tab> :bn<CR>
"nnoremap <S-Tab> :bp<CR>
nnoremap <silent> [b :bp<CR>
nnoremap <silent> ]b :bn<CR>
nnoremap <silent> [B :bp<CR>
nnoremap <silent> ]B :bn<CR>
"### Cursor
cnoreabbrev cul set cul
cnoreabbrev nocul set nocul
"### Pesquisa no arquivo
" Centralizar resultados
nnoremap n nzzzv
nnoremap N Nzzzv

" Limpa highlight da pesquisa
nnoremap <leader>/ :noh<cr>
"### Remove utilização de setas
noremap <up> <nop>
noremap <down> <nop>
noremap <left> <nop>
noremap <right> <nop>
inoremap <up> <nop>
inoremap <down> <nop>
inoremap <left> <nop>
inoremap <right> <nop>
inoremap <c-k> <up>
inoremap <c-j> <down>
inoremap <c-h> <left>
inoremap <c-l> <right>
"### Git greps
" Créditos: https://www.commandlinefu.com/commands/view/12833/get-a-list-of-all-todofixme-tasks-left-to-be-done-in-your-project
"":lvimgrep /\[ \]/ % | lw
command Tasks !git grep -EIn "TODO|FIXME"'
"### CTAGS
" Necessario instalar ctags ou universal ctags
" Att ctags
command Ctags !ctags -R .<CR>

" Goto definition
nnoremap <leader>t :tn <c-r><c-w><CR>
"### Split
" Open the same file
noremap <leader>h :<C-u>split<CR>
noremap <leader>v :<C-u>vsplit<CR>
" Search an file
noremap <leader>l :<C-u>vsp
noremap <leader>j :<C-u>sp

" Switching windows
"   Igual ao dwm
noremap <c-j> <C-w>w
noremap <c-k> <C-w>W

" Resize
nmap <C-w>j <C-w>-
nmap <c-w>k <C-w>+
nmap <c-w>l <C-w>>
nmap <c-w>h <C-w><

" Close all splits
noremap <Leader>e :on<CR>
"## Copy paste
set clipboard=unnamed
noremap <leader>y my^vg_"+y:echo "Copiado!!"<CR>
vnoremap <leader>y "+y:echo "Copiado!!"<CR>
"## Configuração específicas de sistema operacional
""autocmd BufRead * call Dos2unix()
"## Comandos/configurações específicas do buffer aberto
" Créditos: https://stackoverflow.com/a/24046914
let s:comment_map = { 
            \   "c": '\/\/',
            \   "cpp": '\/\/',
            \   "dot": '\/\/',
            \   "go": '\/\/',
            \   "java": '\/\/',
            \   "javascript": '\/\/',
            \   "lua": '--',
            \   "scala": '\/\/',
            \   "php": '\/\/',
            \   "python": '#',
            \   "ruby": '#',
            \   "rust": '\/\/',
            \   "sh": '#',
            \   "desktop": '#',
            \   "fstab": '#',
            \   "conf": '#',
            \   "profile": '#',
            \   "bashrc": '#',
            \   "bash_profile": '#',
            \   "mail": '>',
            \   "eml": '>',
            \   "bat": 'REM',
            \   "ahk": ';',
            \   "vim": '"',
            \   "tex": '%',
            \ }

function! ToggleComment()
    if has_key(s:comment_map, &filetype)
        let comment_leader = s:comment_map[&filetype]
        if getline('.') =~ "^\\s*" . comment_leader . " " 
            " Uncomment the line
            execute "silent s/^\\(\\s*\\)" . comment_leader . " /\\1/"
        else 
            if getline('.') =~ "^\\s*" . comment_leader
                " Uncomment the line
                execute "silent s/^\\(\\s*\\)" . comment_leader . "/\\1/"
            else
                " Comment the line
                execute "silent s/^\\(\\s*\\)/\\1" . comment_leader . " /"
            end
        end
    end
endfunction

nnoremap gcc :call ToggleComment()<cr>
vnoremap gcc :call ToggleComment()<cr>

"### HTML
augroup html
    " Comenta
    au FileType html vnoremap // I<!--<esc>A--><CR>
    au FileType html vnoremap /; :s/^\([/(]\*\\|<!--\) \(.*\) \(\*[/)]\\|-->\)$/\2/<CR>:noh<CR>
    au FileType html nmap // I<!--<esc>A--><CR>
    au FileType html nmap /; :s/^\([/(]\*\\|<!--\) \(.*\) \(\*[/)]\\|-->\)$/\2/<CR>:noh<CR>
augroup END
"### SVELTE
augroup svelte
    au BufReadPost *.svelte set syntax=html
augroup END

"### MARKDOWN
"augroup markdown
"augroup END
"### DOT GV
au! BufRead,BufNewFile *.gv setfiletype dot
augroup dot
    au FileType dot nmap <leader>r <Esc>:w<CR>:call LimpaTerminal()<CR>:!dot -Tpdf -O %<CR><CR>
    au FileType dot nmap <leader>i <Esc>:w<CR>:call LimpaTerminal()<CR>:!dot -Tpng % -O<CR><CR>
augroup END
"### SHELL
"augroup sh
"augroup END
"### LATEX
"augroup tex
"    " Comenta
"    " É necessário compilar duas vezes para ter certeza de atualizar a toc
"    " https://tex.stackexchange.com/questions/301103/empty-table-of-contents
"    " Também compilar bibliografia e mais uma vez a toc
"    " Erros salvos em log
"    au FileType tex nmap <leader>r <Esc>:w<CR>:!clear;pdflatex '%:r' > pdflatex.log<CR><CR>:!clear;pdflatex '%:r' > pdflatex.log<CR><CR>:!clear;bibtex '%:r' > bibtex.log<CR><CR>:!clear;pdflatex '%:r' > pdflatex.log<CR><CR>:!clear;pdflatex '%:r' > pdflatex.log<CR><CR>
"    au FileType tex nmap <leader>e <Esc>:!clear;$PDFVIEWER '%:r'.pdf &<CR><CR>
"augroup END
"
"" Reconhecer classes com syntax de latex
"au BufNewFile,BufRead *.cls set filetype=tex
"### PYTHON
augroup python
    au FileType python nmap <leader>r :vsp<CR>:terminal python3 %<CR>
augroup END
"### PHP
augroup php
    " https://vim.fandom.com/wiki/Runtime_syntax_check_for_php
    " Para usar o :make % e ver erro de syntax
    au FileType php compiler php
    au FileType php set errorformat=%m\

    " Map para executar comando de teste do composer
    " echo "<?php system('composer test');" > neni-composer-test.php
    au FileType php nmap <leader>ct :terminal php neni-composer-test.php<CR>

    au FileType php nmap <leader>r :terminal php %<CR>
augroup END
"### JAVASCRIPT
"augroup javascript
"augroup END
"### Netrw
" Netrw no lugar do nerdtree
" Toggle diretórios à esquerda
"noremap <leader><CR> :Lexplore<CR>

" Configura para apagar o buffer vazio deixado pelo :Lexplore, thanks tpope
au Filetype netrw setl bufhidden=delete
"## Snippets
" :ia
highlight link NeniTagJump DiffAdd
match NeniTagJump /<++>/

function JumpToTag()
    " search retorna a linha onde o parametro foi encontrado
    if search("<++>",'nw') > 0
        " posiciona o cursor sob o padrão da marcação
        call search("<++>",'w')
        " Caso a marcação esteja na ultima coluna da linha, o :startinsert
        " recua uma coluna a mais. Como seria muito complexo calcular essa
        " situação, é mais fácil entrar no modo de insert e apagar o numero
        " de letras (4 para <++>)
        call feedkeys("i\<del>\<del>\<del>\<del>")
    endif
endfun
inoremap <c-tab> <esc>:call JumpToTag()<cr>
nnoremap <c-tab> <esc>:call JumpToTag()<cr>

" Cancela autotrigger snippet com qualquer "non-keyword"
" Créditos: https://stackoverflow.com/questions/36702371/understand-iabbrev-buffer-iff-ifleft
function LeSnippet(root, file)
    let c = nr2char(getchar(0))
    if c == "\<tab>"
        " Assim que a função é chamada o modo é trocado do insert pro normal
        " deslocando o cursor para a direita. Caso não esteja na primeira
        " coluna, ele não se move, afetando a escolha entre i (insert) e a
        " (apend)
        if col(".") == 1
            " Coloca dois marcadores (§):
            " O primeiro demarca o final da linha [l1] (inicio do snippet) e o
            " segundo o inicio da ultima linha [l2] (final do snippet)
            execute "normal i§§"
        else
            " Coloca dois marcadores (§):
            " O primeiro demarca o final da linha [l1] (inicio do snippet) e o
            " segundo o inicio da ultima linha [l2] (final do snippet)
            execute "normal a§§"
        endif
        " Acessa entre os marcadores (§§) e da um enter para quebrar a linha.
        " O marcador preservará o espaço contido antes e depois do mesmo,
        " evitando que o J crie um espaço caso não precise ou unifique caso ja
        " exista
        execute "normal i\<cr>"

        " Marca l2 (mark s) e sobe para a linha inicial
        normal msk

        " Escreve o conteudo do snippet logo abaixo da linha inicial
        execute "read" . a:file

        " - Marca a primeira linha do snippet lido (mark d)
        " - Unifica l1 com a primeira do snippet
        " - Move para esquerda e apaga o espaço gerado pelo J e o marcador (§)
        " - Retorna à l2
        " - Unifica l2 com a ultima do snippet
        " - Apaga o espaço gerado pelo J e o marcador (§) restante mantendo o y
        " - Seleciona de l2 unificada até l1 unificada com o snippet e identa
        normal mdkJh"_x"_x`skJ"_x"_xV`d=
        call JumpToTag()
    elseif c == "\<esc>"
        " a:root . c vai tornar recursiva a função.
        " É necessário colocar uma letra que não seja non-keyword para depois
        " apagá-la
        execute "normal a" . a:root . 'a'
        execute 'normal "_x'
    else
        " a:root . c vai tornar recursiva a função.
        " É necessário colocar uma letra que não seja non-keyword para depois
        " apagá-la
        execute "normal a" . a:root . '"_c' . c
        execute 'normal h"_x'
        startinsert
        call cursor( line('.'), col('.') + 1)
    endif
endfunction

function! CriaSnippet(root, good)
    execute "iabbr <buffer> " . a:root . " <esc>:call LeSnippet(\"" . a:root . "\", \"" . a:good . "\")<cr>"
endfunction

function! RegistraArraySnippets(snippet)
    for key in keys(a:snippet)
        execute CriaSnippet(key, a:snippet[key])
    endfor
endfunction

let s:snippetsDir = '~/dev/dotfiles/vim/snippets/'
let s:snippetsDirPHP = s:snippetsDir . 'php/'
let s:snippets_php_abbreviations = {
            \ 'for': s:snippetsDirPHP.'for.php',
            \ 'fore': s:snippetsDirPHP.'foreach.php',
            \ 'fun': s:snippetsDirPHP.'function.php',
            \ 'if': s:snippetsDirPHP.'if.php',
            \ '-': s:snippetsDirPHP.'private.php',
            \ '#': s:snippetsDirPHP.'protected.php',
            \ '+': s:snippetsDirPHP.'public.php',
            \ 't': s:snippetsDirPHP.'this.php',
            \ 'dd': s:snippetsDirPHP.'var_dump.php',
            \ 'e': s:snippetsDirPHP.'echo.php',
            \ }
let s:snippetsDirJS = s:snippetsDir . 'js/'
let s:snippets_js_abbreviations = {
            \ 'for': s:snippetsDirJS.'for.js',
            \ 'fun': s:snippetsDirJS.'function.js',
            \ 'if': s:snippetsDirJS.'if.js',
            \ 'log': s:snippetsDirJS.'log.js',
            \ }
let s:snippetsDirHTML = s:snippetsDir . 'html/'
let s:snippets_html_abbreviations = {
            \ 'div': s:snippetsDirHTML.'div.html',
            \ }

au FileType php call RegistraArraySnippets(s:snippets_php_abbreviations)
au FileType javascript call RegistraArraySnippets(s:snippets_js_abbreviations)
au FileType html call RegistraArraySnippets(s:snippets_js_abbreviations)
au FileType html call RegistraArraySnippets(s:snippets_html_abbreviations)


"## Comandos/configurações específicas do buffer aberto (linguagens de programação comumente)
"### HTML
augroup html
    au BufNewFile *.html 0r ~/dev/dotfiles/vim/skeletons/skeleton.html
"    au FileType html :so ~/dev/dotfiles/vim/plugins/matchit.vim
augroup END
"### PHP
let g:dict_dir = "~/dev/dotfiles/vim/dicionarios/"
augroup php
    au BufNewFile *.php 0r ~/dev/dotfiles/vim/skeletons/skeleton.php
    au BufNewFile phpunit.xml 0r ~/dev/dotfiles/vim/skeletons/phpunit.xml
    au FileType php nmap <leader>r :terminal php %<CR>
au BufRead *test.php execute "setlocal dictionary+=".g:dict_dir."phpunit.dict"

augroup END
"### SHELL
"augroup sh
"    au BufNewFile *.sh 0r ~/dev/dotfiles/vim/skeletons/skeleton.sh
"augroup END
"## colorscheme/syntax
" Ver highlight-groups
"so $VIMRUNTIME/syntax/hitest.vim
""let g:onedark_terminal_italics = 1
" onedark adaptado
" Ver highlight group da palavra sob o cursor
" https://vim.fandom.com/wiki/Identify_the_syntax_highlighting_group_used_at_the_cursor
" :highlight mostra as cores do grupo
command Syntax echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<' . synIDattr(synID(line("."),col("."),0),"name") . "> lo<" . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"
highlight CursorColumn guibg=#0a0c0f
highlight CursorLine guibg=#0a0c0f gui=underline cterm=underline
hi! Folded guibg=purple
"command Apr call AprRead()
" ==============================================================================
"   Name:        One Half Dark
"   Author:      Son A. Pham <sp@sonpham.me>
"   Url:         https://github.com/sonph/onehalf
"   License:     The MIT License (MIT)
"
"   A dark vim color scheme based on Atom's One. See github.com/sonph/onehalf
"   for installation instructions, a light color scheme, versions for other
"   editors/terminals, and a matching theme for vim-airline.
" ==============================================================================

set background=dark
highlight clear
syntax reset

let g:colors_name="onehalfdark"
let colors_name="onehalfdark"


let s:black       = { "gui": "#282c34", "cterm": "236" }
let s:red         = { "gui": "#e06c75", "cterm": "168" }
let s:green       = { "gui": "#98c379", "cterm": "114" }
let s:yellow      = { "gui": "#e5c07b", "cterm": "180" }
let s:blue        = { "gui": "#61afef", "cterm": "75"  }
let s:purple      = { "gui": "#c678dd", "cterm": "176" }
let s:cyan        = { "gui": "#56b6c2", "cterm": "73"  }
let s:white       = { "gui": "#dcdfe4", "cterm": "188" }

let s:fg          = s:white
let s:bg          = s:black

let s:comment_fg  = { "gui": "#5c6370", "cterm": "241" }
let s:gutter_bg   = { "gui": "#282c34", "cterm": "236" }
let s:gutter_fg   = { "gui": "#919baa", "cterm": "247" }

let s:cursor_line = { "gui": "#313640", "cterm": "237" }
let s:color_col   = { "gui": "#313640", "cterm": "237" }

let s:selection   = { "gui": "#474e5d", "cterm": "239" }
let s:vertsplit   = { "gui": "#313640", "cterm": "237" }


function! s:h(group, fg, bg, attr)
  if type(a:fg) == type({})
    exec "hi " . a:group . " guifg=" . a:fg.gui . " ctermfg=" . a:fg.cterm
  else
    exec "hi " . a:group . " guifg=NONE cterm=NONE"
  endif
  if type(a:bg) == type({})
    exec "hi " . a:group . " guibg=" . a:bg.gui . " ctermbg=" . a:bg.cterm
  else
    exec "hi " . a:group . " guibg=NONE ctermbg=NONE"
  endif
  if a:attr != ""
    exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
  else
    exec "hi " . a:group . " gui=NONE cterm=NONE"
  endif
endfun


" User interface colors {
call s:h("NonText", s:fg, "", "")

call s:h("Cursor", s:bg, s:blue, "")
call s:h("CursorColumn", "", s:cursor_line, "")
call s:h("CursorLine", "", s:cursor_line, "")

call s:h("LineNr", s:gutter_fg, "", "")
call s:h("CursorLineNr", s:fg, "", "")

call s:h("DiffAdd", "", s:green, "")
call s:h("DiffChange", "", s:yellow, "")
call s:h("DiffDelete", "", s:red, "")
call s:h("DiffText", s:blue, "", "")

call s:h("IncSearch", s:bg, s:yellow, "")
call s:h("Search", s:bg, s:yellow, "")

call s:h("ErrorMsg", s:fg, "", "")
call s:h("ModeMsg", s:fg, "", "")
call s:h("MoreMsg", s:fg, "", "")
call s:h("WarningMsg", s:red, "", "")
call s:h("Question", s:purple, "", "")

call s:h("Pmenu", s:bg, s:fg, "")
call s:h("PmenuSel", s:fg, s:blue, "")
call s:h("PmenuSbar", "", s:selection, "")
call s:h("PmenuThumb", "", s:fg, "")

call s:h("SpellBad", s:red, "", "")
call s:h("SpellCap", s:yellow, "", "")
call s:h("SpellLocal", s:yellow, "", "")
call s:h("SpellRare", s:yellow, "", "")

call s:h("StatusLine", s:blue, s:cursor_line, "")
call s:h("StatusLineNC", s:comment_fg, s:cursor_line, "")
call s:h("TabLine", s:comment_fg, s:cursor_line, "")
call s:h("TabLineFill", s:comment_fg, s:cursor_line, "")
call s:h("TabLineSel", s:fg, s:bg, "")

call s:h("Visual", "", s:selection, "")
call s:h("VisualNOS", "", s:selection, "")

call s:h("ColorColumn", "", s:color_col, "")
call s:h("Conceal", s:fg, "", "")
call s:h("Directory", s:blue, "", "")
call s:h("VertSplit", s:vertsplit, s:vertsplit, "")
call s:h("Folded", s:fg, "", "")
call s:h("FoldColumn", s:fg, "", "")
call s:h("SignColumn", s:fg, "", "")

call s:h("MatchParen", s:blue, "", "underline")
call s:h("SpecialKey", s:fg, "", "")
call s:h("Title", s:green, "", "")
call s:h("WildMenu", s:fg, "", "")
" }


" Syntax colors {
call s:h("Comment", s:comment_fg, "", "")
call s:h("Constant", s:cyan, "", "")
call s:h("String", s:green, "", "")
call s:h("Character", s:green, "", "")
call s:h("Number", s:yellow, "", "")
call s:h("Boolean", s:yellow, "", "")
call s:h("Float", s:yellow, "", "")

call s:h("Identifier", s:red, "", "")
call s:h("Function", s:blue, "", "")
call s:h("Statement", s:purple, "", "")

call s:h("Conditional", s:purple, "", "")
call s:h("Repeat", s:purple, "", "")
call s:h("Label", s:purple, "", "")
call s:h("Operator", s:fg, "", "")
call s:h("Keyword", s:red, "", "")
call s:h("Exception", s:purple, "", "")

call s:h("PreProc", s:yellow, "", "")
call s:h("Include", s:blue, "", "")
call s:h("Define", s:purple, "", "")
call s:h("Macro", s:purple, "", "")
call s:h("PreCondit", s:yellow, "", "")

call s:h("Type", s:yellow, "", "")
call s:h("StorageClass", s:yellow, "", "")
call s:h("Structure", s:yellow, "", "")
call s:h("Typedef", s:yellow, "", "")

call s:h("Special", s:blue, "", "")
call s:h("SpecialChar", s:fg, "", "")
call s:h("Tag", s:fg, "", "")
call s:h("Delimiter", s:fg, "", "")
call s:h("SpecialComment", s:fg, "", "")
call s:h("Debug", s:fg, "", "")
call s:h("Underlined", s:fg, "", "")
call s:h("Ignore", s:fg, "", "")
call s:h("Error", s:red, s:gutter_bg, "")
call s:h("Todo", s:purple, "", "")
" }


" Plugins {
" GitGutter
call s:h("GitGutterAdd", s:green, s:gutter_bg, "")
call s:h("GitGutterDelete", s:red, s:gutter_bg, "")
call s:h("GitGutterChange", s:yellow, s:gutter_bg, "")
call s:h("GitGutterChangeDelete", s:red, s:gutter_bg, "")
" Fugitive
call s:h("diffAdded", s:green, "", "")
call s:h("diffRemoved", s:red, "", "")
" }


" Git {
call s:h("gitcommitComment", s:comment_fg, "", "")
call s:h("gitcommitUnmerged", s:red, "", "")
call s:h("gitcommitOnBranch", s:fg, "", "")
call s:h("gitcommitBranch", s:purple, "", "")
call s:h("gitcommitDiscardedType", s:red, "", "")
call s:h("gitcommitSelectedType", s:green, "", "")
call s:h("gitcommitHeader", s:fg, "", "")
call s:h("gitcommitUntrackedFile", s:cyan, "", "")
call s:h("gitcommitDiscardedFile", s:red, "", "")
call s:h("gitcommitSelectedFile", s:green, "", "")
call s:h("gitcommitUnmergedFile", s:yellow, "", "")
call s:h("gitcommitFile", s:fg, "", "")
hi link gitcommitNoBranch gitcommitBranch
hi link gitcommitUntracked gitcommitComment
hi link gitcommitDiscarded gitcommitComment
hi link gitcommitSelected gitcommitComment
hi link gitcommitDiscardedArrow gitcommitDiscardedFile
hi link gitcommitSelectedArrow gitcommitSelectedFile
hi link gitcommitUnmergedArrow gitcommitUnmergedFile
" }

" Fix colors in neovim terminal buffers {
  if has('nvim')
    let g:terminal_color_0 = s:black.gui
    let g:terminal_color_1 = s:red.gui
    let g:terminal_color_2 = s:green.gui
    let g:terminal_color_3 = s:yellow.gui
    let g:terminal_color_4 = s:blue.gui
    let g:terminal_color_5 = s:purple.gui
    let g:terminal_color_6 = s:cyan.gui
    let g:terminal_color_7 = s:white.gui
    let g:terminal_color_8 = s:black.gui
    let g:terminal_color_9 = s:red.gui
    let g:terminal_color_10 = s:green.gui
    let g:terminal_color_11 = s:yellow.gui
    let g:terminal_color_12 = s:blue.gui
    let g:terminal_color_13 = s:purple.gui
    let g:terminal_color_14 = s:cyan.gui
    let g:terminal_color_15 = s:white.gui
    let g:terminal_color_foreground = s:fg.gui
  endif
" }

